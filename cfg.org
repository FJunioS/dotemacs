#+TITLE: Ju' Emacs config

* Bootstrap
** early-init.el
:PROPERTIES:
:header-args: :noweb-ref early-init-cfg
:END:

#+BEGIN_SRC elisp :tangle early-init.el :noweb-ref :noweb yes
;; -*- lexical-binding: t; -*-

<<early-init-cfg>>

;;; early-init.el ends here.
#+END_SRC

#+begin_src elisp
  ;; test
#+end_src

** Core lib
*** Lib
:PROPERTIES:
:header-args: :noweb-ref core-lib-cfg
:END:

- =core-lib= file template
#+BEGIN_SRC elisp :tangle core/core-lib.el :noweb-ref :noweb yes
;; -*- lexical-binding: t; -*-

<<core-lib-cfg>>

(provide 'core-lib)
;;; core-lib.el ends here.
#+END_SRC

#+begin_src elisp
(require 'cl-lib)

(define-error 'config-error "An unexpected config error")
(define-error 'core-error "Unexpected error in Emacs Config's CORE layer" 'config-error)
(define-error 'hook-error "Error in a Config startup hook" 'config-error)
(define-error 'autoload-error "Error in config's autoloads file" 'config-error)
(define-error 'user-error "Error caused by user's config or system" 'config-error)
(define-error 'module-error "Error in a config module" 'config-error)
(define-error 'package-error "Error with packages" 'config-error)
(define-error 'cache-error "Error while processing cache" 'config-error)

(defvar +inhibit-log (not (or noninteractive init-file-debug))
  "If non-nil, suppress `+log' output.")

(defun __log (text &rest args)
  (let ((inhibit-message (not init-file-debug))
        (absolute? (string-prefix-p ":" text)))
    (apply #'message
           (propertize (concat "* %.06f:%s" (if (not absolute?) ":") text)
                       'face 'font-lock-doc-face)
           (float-time (time-subtract (current-time) before-init-time))
           (mapconcat
            (lambda (x) (format "%s" x))
            (unless absolute?
              (append (cons '* (remq t (reverse +context)))
                      (if (bound-and-true-p +module-context)
                          (let ((key (+module-context-key)))
                            (delq nil (list (car key) (cdr key)))))))
            ":")
           args)))

(defmacro +log (message &rest args)
  "Log a message in *Messages*.

Does not emit the MESSAGE in the echo area.
This is a macro instead of a function to prevent the potentially expensive
evaluation of its arguments when debug mode is off.
Return ARGS non-nil."
  (declare (debug t))
  `(unless +inhibit-log (__log ,message ,@args)))

(defalias '+partial #'apply-partially)

(defmacro null-or! (&rest body)
  `(satisfies (lambda (x) (or (null x) (,@body)))))

(defmacro after! (package &rest body)
  "Evaluate BODY after PACKAGE have loaded.

PACKAGE is a symbol (or list of them) referring to Emacs features (aka
packages). PACKAGE may use :or/:any and :and/:all operators. The precise format
is:

- An unquoted package symbol (the name of a package)
    (after! helm BODY...)
- An unquoted, nested list of compound package lists, using any combination of
  :or/:any and :and/:all
    (after! (:or package-a package-b ...)  BODY...)
    (after! (:and package-a package-b ...) BODY...)
    (after! (:and package-a (:or package-b package-c) ...) BODY...)
- An unquoted list of package symbols (i.e. BODY is evaluated once both magit
  and git-gutter have loaded)
    (after! (magit git-gutter) BODY...)
  If :or/:any/:and/:all are omitted, :and/:all are implied.

This emulates `eval-after-load' with a few key differences:

1. Supports compound package statements (see :or/:any and :and/:all above).

Since the contents of these blocks will never by byte-compiled, avoid putting
things you want byte-compiled in them! Like function/macro definitions."
  (declare (indent defun) (debug t))
  (if (symbolp package)
      (unless (memq package (bound-and-true-p doom-disabled-packages))
        (list (if (or (not (bound-and-true-p byte-compile-current-file))
                      (require package nil 'noerror))
                  #'progn
                #'with-no-warnings)
              `(with-eval-after-load ',package ,@body)))
    (let ((p (car package)))
      (cond ((memq p '(:or :any))
             (macroexp-progn
              (cl-loop for next in (cdr package)
                       collect `(after! ,next ,@body))))
            ((memq p '(:and :all))
             (dolist (next (reverse (cdr package)) (car body))
               (setq body `((after! ,next ,@body)))))
            (`(after! (:and ,@package) ,@body))))))

(defun load! (path &optional noerror)
  "Load PATH and handle any config errors that may arise from it.

If NOERROR, don't throw an error if PATH doesn't exist."
  (+log "load: %s %s" (abbreviate-file-name path) noerror)
  (condition-case-unless-debug e
      (load path noerror 'nomessage)
    (config-error
     (signal (car e) (cdr e)))
    (error
     (setq path (locate-file path load-path (get-load-suffixes)))
     (signal (cond ((not (and path (featurep 'config)))
                    'error)
                   ((file-in-directory-p path core-dir)
                    'core-error)
                   ((file-in-directory-p path user-dir)
                    'user-error)
                   ((file-in-directory-p path cache-dir)
                    'cache-error)
                   ((file-in-directory-p path layers-dir)
                    'module-error)
                   ('config-error))
             (list path e)))))

(defun require! (feature &optional filename noerror)
  "Evaluate FEATURE, just like `require', but handles and enhances errors.

Can also load subfeatures, e.g. (require! '+some-lib 'some-files)"
  (let ((subfeature (if (symbolp filename) filename)))
    (or (featurep feature subfeature)
        (load!
         (if subfeature
             (file-name-concat core-dir
                               (string-remove-prefix "+" (symbol-name feature))
                               (symbol-name filename))
           (symbol-name feature))
         noerror))))


(defun __resolve-hook-forms (hooks)
  "Converts a list of modes into a list of hook symbols.

If a mode is quoted, it is left as is. If the entire HOOKS list is quoted, the
list is returned as-is."
  (declare (pure t) (side-effect-free t))
  (let ((hook-list (ensure-list (+unquote hooks))))
    (if (eq (car-safe hooks) 'quote)
        hook-list
      (cl-loop for hook in hook-list
               if (eq (car-safe hook) 'quote)
               collect (cadr hook)
               else collect (intern (format "%s-hook" (symbol-name hook)))))))

(defmacro letf! (bindings &rest body)
  "Temporarily rebind function, macros, and advice in BODY.

Intended as syntax sugar for `cl-letf', `cl-labels', `cl-macrolet', and
temporary advice.

BINDINGS is either:

  A list of, or a single, `defun', `defun*', `defmacro', or `defadvice' forms.
  A list of (PLACE VALUE) bindings as `cl-letf*' would accept.

TYPE is one of:

  `defun' (uses `cl-letf')
  `defun*' (uses `cl-labels'; allows recursive references),
  `defmacro' (uses `cl-macrolet')
  `defadvice' (uses `defadvice!' before BODY, then `undefadvice!' after)

NAME, ARGLIST, and BODY are the same as `defun', `defun*', `defmacro', and
`defadvice!', respectively.

\(fn ((TYPE NAME ARGLIST &rest BODY) ...) BODY...)"
  (declare (indent defun))
  (setq body (macroexp-progn body))
  (when (memq (car bindings) '(defun defun* defmacro defadvice))
    (setq bindings (list bindings)))
  (dolist (binding (reverse bindings) body)
    (let ((type (car binding))
          (rest (cdr binding)))
      (setq
       body (pcase type
              (`defmacro `(cl-macrolet ((,@rest)) ,body))
              (`defadvice `(progn (defadvice! ,@rest)
                                  (unwind-protect ,body (undefadvice! ,@rest))))
              ((or `defun `defun*)
               `(cl-letf ((,(car rest) (symbol-function #',(car rest))))
                  (ignore ,(car rest))
                  ,(if (eq type 'defun*)
                       `(cl-labels ((,@rest)) ,body)
                     `(cl-letf (((symbol-function #',(car rest))
                                 (lambda! ,(cadr rest) ,@(cddr rest))))
                        ,body))))
              (_
               (when (eq (car-safe type) 'function)
                 (setq type (list 'symbol-function type)))
               (list 'cl-letf (list (cons type rest)) body)))))))

(defun +unquote (exp)
  "Return EXP unquoted."
  (declare (pure t) (side-effect-free t))
  (while (memq (car-safe exp) '(quote function))
    (setq exp (cadr exp)))
  exp)

(defun +keyword-intern (str)
  "Converts STR (a string) into a keyword (`keywordp')."
  (declare (pure t) (side-effect-free t))
  (cl-check-type str string)
  (intern (concat ":" str)))

(defun +keyword-name (keyword)
  "Returns the string name of KEYWORD (`keywordp') minus the leading colon."
  (declare (pure t) (side-effect-free t))
  (cl-check-type keyword keyword)
  (substring (symbol-name keyword) 1))

(defun +rpartial (fn &rest args)
  "Return a partial application of FUN to right-hand ARGS.

ARGS is a list of the last N arguments to pass to FUN. The result is a new
function which does the same as FUN, except that the last N arguments are fixed
at the values with which this function was called."
  (declare (side-effect-free t))
  (lambda (&rest pre-args)
    (apply fn (append pre-args args))))

(defun +lookup-key (keys &rest keymaps)
  "Like `lookup-key', but search active keymaps if KEYMAP is omitted."
  (if keymaps
      (cl-some (+rpartial #'lookup-key keys) keymaps)
    (cl-loop for keymap
             in (append (cl-loop for alist in emulation-mode-map-alists
                                 append (mapcar #'cdr
                                                (if (symbolp alist)
                                                    (if (boundp alist) (symbol-value alist))
                                                  alist)))
                        (list (current-local-map))
                        (mapcar #'cdr minor-mode-overriding-map-alist)
                        (mapcar #'cdr minor-mode-map-alist)
                        (list (current-global-map)))
             if (keymapp keymap)
             if (lookup-key keymap keys)
             return it)))

(defmacro add-hook! (hooks &rest rest)
  "A convenience macro for adding N functions to M hooks.

This macro accepts, in order:

  1. The mode(s) or hook(s) to add to. This is either an unquoted mode, an
    unquoted list of modes, a quoted hook variable or a quoted list of hook
    variables.
  2. Optional properties :local, :append, and/or :depth [N], which will make the
    hook buffer-local or append to the list of hooks (respectively),
  3. The function(s) to be added: this can be a quoted function, a quoted list
    thereof, a list of `defun' or `cl-defun' forms, or arbitrary forms (will
    implicitly be wrapped in a lambda).

\(fn HOOKS [:append :local [:depth N]] FUNCTIONS-OR-FORMS...)"
  (declare (indent (lambda (indent-point state)
                     (goto-char indent-point)
                     (when (looking-at-p "\\s-*(")
                       (lisp-indent-defform state indent-point))))
           (debug t))
  (let* ((hook-forms (__resolve-hook-forms hooks))
         (func-forms ())
         (defn-forms ())
         append-p local-p remove-p depth)
    (while (keywordp (car rest))
      (pcase (pop rest)
        (:append (setq append-p t))
        (:depth  (setq depth (pop rest)))
        (:local  (setq local-p t))
        (:remove (setq remove-p t))))
    (while rest
      (let* ((next (pop rest))
             (first (car-safe next)))
        (push (cond ((memq first '(function nil))
                     next)
                    ((eq first 'quote)
                     (let ((quoted (cadr next)))
                       (if (atom quoted)
                           next
                         (when (cdr quoted)
                           (setq rest (cons (list first (cdr quoted)) rest)))
                         (list first (car quoted)))))
                    ((memq first '(defun cl-defun))
                     (push next defn-forms)
                     (list 'function (cadr next)))
                    ((prog1 `(lambda (&rest _) ,@(cons next rest))
                       (setq rest nil))))
              func-forms)))
    `(progn
       ,@defn-forms
       (dolist (hook (nreverse ',hook-forms))
         (dolist (func (list ,@func-forms))
           ,(if remove-p
                `(remove-hook hook func ,local-p)
              `(add-hook hook func ,(or depth append-p) ,local-p)))))))


(defmacro unsetq-hook! (hooks &rest vars)
  "Unbind setq hooks on HOOKS for VARS.

\(fn HOOKS &rest [SYM VAL]...)"
  (declare (indent 1))
  (macroexp-progn
   (cl-loop for (_var _val hook fn)
            in (doom--setq-hook-fns hooks vars 'singles)
            collect `(remove-hook ',hook #',fn))))


;;; Definers
(defmacro defadvice! (symbol arglist &optional docstring &rest body)
  "Define an advice called SYMBOL and add it to PLACES.

ARGLIST is as in `defun'. WHERE is a keyword as passed to `advice-add', and
PLACE is the function to which to add the advice, like in `advice-add'.
DOCSTRING and BODY are as in `defun'.

\(fn SYMBOL ARGLIST &optional DOCSTRING &rest [WHERE PLACES...] BODY\)"
  (declare (doc-string 3) (indent defun))
  (unless (stringp docstring)
    (push docstring body)
    (setq docstring nil))
  (let (where-alist)
    (while (keywordp (car body))
      (push `(cons ,(pop body) (ensure-list ,(pop body)))
            where-alist))
    `(progn
       (defun ,symbol ,arglist ,docstring ,@body)
       (dolist (targets (list ,@(nreverse where-alist)))
         (dolist (target (cdr targets))
           (advice-add target (car targets) #',symbol))))))



(defvar __hook nil)
(defun +run-hook (hook)
  "Run HOOK (a hook function) with better error handling.
Meant to be used with `run-hook-wrapped'."
  (+log "hook:%s: run %s" (or __hook '*) hook)
  (condition-case-unless-debug e
      (funcall hook)
    (error
     (signal 'hook-error (list hook e))))
  ;; return nil so `run-hook-wrapped' won't short circuit
  nil)


(defun +default-monitor-geometry ()
  "Return geometry for the first monitor in `display-monitor-attributes-list'."
  (let* ((first-monitor (car (display-monitor-attributes-list))))
    (alist-get 'geometry first-monitor)))

(defun +default-monitor-width ()
  "Return the width of the first monitor in `display-monitor-attributes-list'."
  (nth 2 (+default-monitor-geometry)))

(defun +default-monitor-height ()
  "Return the height of the first monitor in `display-monitor-attributes-list'."
  (nth 3 (+default-monitor-geometry)))


(defun +border-width ()
  "Return the width to use for borders.
Uses 4 pixels FHD and 8 on 4k."
  (round (* 0.00208333333 (+default-monitor-width))))

(defun +mode-line-height ()
  (round (* 0.00911458333333333 (+default-monitor-width))))

(defun +smaller-mode-line-height ()
  (round (* 0.0078125 (+default-monitor-width))))

(defun vsplit ()
  "Vertically split window and switch to new window."
  (interactive)
  (split-window-below)
  (other-window 1)
  (balance-windows))

(defun hsplit ()
  "Horizontally split window and switch to new window."
  (interactive)
  (split-window-right)
  (other-window 1)
  (balance-windows))

(defun +switch-to-messages ()
  (interactive)
  (switch-to-buffer "*Messages*"))

;;;###autoload
(defmacro csetq (&rest settings)
  `(progn
     ,@(cl-loop for (var val) on settings by 'cddr
                collect `(funcall (or (get ',var 'custom-set) #'set)
                                  ',var ,val))))

(defmacro csetq-default (&rest settings)
  "An alias for `setq-default'."
  `(setq-default ,@settings))

(defmacro create-keymap (key &rest docstring)
  "Create a keymap KEY with DOCSTRING."
  `(progn
     (defvar ,key (make-sparse-keymap) ,docstring)
     (defalias ',key ,key ,(format "An alias for %s keymap." (symbol-name key)))))

(defmacro map (mode &rest keymaps)
  `(progn
     ,@(cl-loop for (hk fn) on keymaps by 'cddr
                collect `(funcall #'define-key ,mode ,(kbd hk) ,(if (stringp fn) (kbd fn) fn)))))

(defmacro global-map (&rest keymaps)
  `(progn
     ,@(cl-loop for (hk fn) on keymaps by 'cddr
                collect `(funcall #'global-set-key ,(kbd hk) ,(if (stringp fn) (kbd fn) fn)))))
(defalias #'global-key #'global-map)

(defmacro +map (map &rest bindings)
  `(progn
     ,@(seq-map (lambda (pair)
                  `(define-key! ,map (kbd ,(car pair)) ,(cadr pair)))
                (seq-partition bindings 2))))

(defmacro define-key! (map keybind command)
  `(define-key ,map (kbd ,keybind) ',command))

(defmacro defun! (name arglist &optional docstring &rest body)
  "declare `defun' and return the function instead of a unit."
  (declare (doc-string 3) (indent 2))
  `(progn (defun ,name ,arglist ,docstring ,@body)
          #',name))

(defmacro pushnew! (place &rest values)
  "Push VALUES sequentially into PLACE, if they aren't already present.
This is a variadic `cl-pushnew'."
  (let ((var (make-symbol "result")))
    `(dolist (,var (list ,@values) (with-no-warnings ,place))
       (cl-pushnew ,var ,place :test #'equal))))

(defmacro run-at-interval! (interval idle-interval &rest body)
  "Every INTERVAL seconds, unless idle for > IDLE-INTERVAL seconds, run BODY.
    Also, after IDLE-INTERVAL seconds of idle time, run BODY. This allows using an
    idle timer to quickly run BODY when Emacs becomes idle but also ensures that
    BODY is run periodically even if Emacs is actively being used."
  (declare (indent 2))
  `(progn
     (run-at-time (current-time) ,interval
                  (lambda ()
                    (let* ((idle-time (current-idle-time))
                           (idle-secs (when idle-time
                                        (float-time idle-time))))
                      (unless (and idle-secs
                                   (> idle-secs ,idle-interval))
                        ,@body))))
     (run-with-idle-timer ,idle-interval t (lambda () ,@body))))

(defmacro silently! (&rest body)
  (declare (indent 0) (debug t))
  `(let ((inhibit-message t)
         (save-silently t))
     (cl-letf (((symbol-function 'message) #'ignore))
       ,@body)))

(defmacro add-transient-hook! (hook-or-function &rest forms)
  "Attaches a self-removing function to HOOK-OR-FUNCTION.

FORMS are evaluated once, when that function/hook is first invoked, then never
again.

HOOK-OR-FUNCTION can be a quoted hook or a sharp-quoted function (which will be
advised)."
  (declare (indent 1))
  (let ((append? (if (eq (car forms) :after) (pop forms)))
        (fn (gensym "+transient-hook")))
    `(let ((sym ,hook-or-function))
       (defun ,fn (&rest _)
         ,(format "Transient hook for %S" (+unquote hook-or-function))
         ,@forms
         (let ((sym ,hook-or-function))
           (cond ((functionp sym) (advice-remove sym #',fn))
                 ((symbolp sym)   (remove-hook sym #',fn))))
         (unintern ',fn nil))
       (cond ((functionp sym)
              (advice-add ,hook-or-function ,(if append? :after :before) #',fn))
             ((symbolp sym)
              (put ',fn 'permanent-local-hook t)
              (add-hook sym #',fn ,append?))))))

(defun +chmod-file()
  (interactive)
  (chmod (buffer-file-name) (read-file-modes)))

(defmacro setq-hook! (hooks &rest var-vals)
  "Sets buffer-local variables on HOOKS.
  \(fn HOOKS &rest [SYM VAL]...)"
  (declare (indent 1))
  (macroexp-progn
   (cl-loop for (var val hook fn) in (__setq-hook-fns hooks var-vals)
            collect `(defun ,fn (&rest _)
                       ,(format "%s = %s" var (pp-to-string val))
                       (setq-local ,var ,val))
            collect `(add-hook ',hook #',fn -90))))

(defun __setq-hook-fns (hooks rest &optional singles)
  (unless (or singles (= 0 (% (length rest) 2)))
    (signal 'wrong-number-of-arguments (list #'evenp (length rest))))
  (cl-loop with vars = (let ((args rest)
                             vars)
                         (while args
                           (push (if singles
                                     (list (pop args))
                                   (cons (pop args) (pop args)))
                                 vars))
                         (nreverse vars))
           for hook in (__resolve-hook-forms hooks)
           for mode = (string-remove-suffix "-hook" (symbol-name hook))
           append
           (cl-loop for (var . val) in vars
                    collect
                    (list var val hook
                          (intern (format "__setq-%s-for-%s-h"
                                          var mode))))))

(defun __split-some-window (frame alist)
  "Return a window if splitting any window was successful.
    This function tries using the largest window on FRAME for
    splitting, if all windows are the same size, the selected one is
    taken, in case this fails, the least recently used window is used
    for splitting.  ALIST is passed to `window--try-to-split-window'
    internally."
  (or (window--try-to-split-window (get-largest-window frame t) alist)
      (window--try-to-split-window (get-lru-window frame t) alist)))

(defun __display-buffer-popup-window (buffer alist)
  "Display BUFFER in a popped up window.
    This is a stripped down version of `shackle--display-buffer-popup-window'.
    ALIST is passed to `shackle--window-display-buffer' internally.
    If PLIST contains the :other key with t as value, reuse the next
    available window if possible."
  (let ((window (if (not (one-window-p))
                    (next-window nil 'nominibuf)
                  (__split-some-window (selected-frame) alist))))
    (window--display-buffer buffer window 'window alist)))

"make-dir! check if directory already existis before acting"
(defun make-dir! (dirr)
  (unless (file-exists-p dirr)
    (make-directory dirr)))

(defun try! (fn)
  "try execute FN, returning nil if ok, error otherwise."
  (condition-case e
      (progn
        (eval fn)
        nil)
    (error e)))

(defun lib/side-window-p ()
  "Return non-nil if the selected window is a side window."
  (window-parameter (selected-window) 'window-side))

(cl-defun lib/file-basename (&optional (file (buffer-file-name)))
  "Return the basename of FILE."
  (file-name-sans-extension (file-name-nondirectory file)))

(defvar escape-hook nil)

(defun escape (&optional interactive)
  "Run `escape-hook'.
INTERACTIVE means that accept the Universal Argument `C-u'"
  (interactive (list 'interactive))
  (cond ((minibuffer-window-active-p (minibuffer-window))
         ;; quit the minibuffer if open.
         (when interactive
           (setq this-command 'abort-recursive-edit))
         (abort-recursive-edit))
        ;; Run all escape hooks. If any returns non-nil, then stop there.
        ((run-hook-with-args-until-success 'escape-hook))
        ;; don't abort macros
        ((or defining-kbd-macro executing-kbd-macro) nil)
        ;; Back to the default
        ((unwind-protect (keyboard-quit)
           (when interactive
             (setq this-command 'keyboard-quit))))))


(defconst interactive-modes-alist
  '(emacs-lisp-mode
    lisp-interaction-mode
    eshell-mode
    clojure-mode
    lisp-mode
    rustic-mode
    rust-mode
    python-mode
    js-mode
    ts-mode
    go-mode
    haskell-mode
    org-mode
    eshell-mode
    shell-script-mode
    prog-mode
    text-mode)
  "List containg all modes that user can write with")

(defconst my/global-map
  '(global-map
    org-mode-map
    prog-mode-map
    text-mode-map
    emacs-lisp-mode-map
    diff-mode-map
    help-mode-map
    eww-mode-map
    pdf-view-mode-map
    lisp-mode-map
    gnus-mode-map
    vterm-mode-map
    shell-mode-map
    eshell-mode-map
    dirvish-mode-map
    message-mode-map
    ibuffer-mode-map
    magit-mode-map
    magit-log-mode-map
    comint-mode-map)
  "List of main modes for keymaps.")

(defmacro after-frame! (&rest body)
  "Run BODY after each frame is created, useful for interface customization."
  `(add-hook 'after-make-frame-functions
             (lambda (frame)
               (select-frame frame)
               (lambda () ,body))))

(defconst ju//minibuffer-maps
  '(minibuffer-local-map
    minibuffer-local-ns-map
    minibuffer-local-completion-map
    minibuffer-local-must-match-map
    minibuffer-local-isearch-map)
  "List of minibuffer keymaps.")

(with-eval-after-load 'eldoc
  (eldoc-add-command 'escape))

(defalias 'expand #'expand-file-name)
(defalias 'bol #'line-beginning-position)
(defalias 'eol #'line-end-position)

(defun buffer-unique-p ()
  "Check if the current buffer is unique among all windows."
  (let ((buffer (current-buffer)))
    (not (cl-loop for win being the windows
                  if (eq buffer (window-buffer win))
                  collect win))))

(defun side-window-p ()
  "Return non-nil if the selected window is a side window."
  (window-parameter (selected-window) 'window-side))

(defmacro run-at-active-interval (interval idle-interval &rest body)
  "Every INTERVAL seconds, unless idle for > IDLE-INTERVAL seconds, run BODY.
Also, after IDLE-INTERVAL seconds of idle time, run BODY. This allows using an
idle timer to quickly run BODY when Emacs becomes idle but also ensures that
BODY is run periodically even if Emacs is actively being used."
  (declare (indent 2))
  `(progn
     (run-at-time (current-time) ,interval
                  (lambda ()
                    (let* ((idle-time (current-idle-time))
                           (idle-secs (when idle-time
                                        (float-time idle-time))))
                      (unless (and idle-secs
                                   (> idle-secs ,idle-interval))
                        ,@body))))
     (run-with-idle-timer ,idle-interval t (lambda () ,@body))))

;;;###autoload
(defun +kill-this-buffer ()
  "`kill-this-buffer' with no menu-bar checks.
`kill-this-buffer' is supposed to be called from the menu bar.
See https://www.reddit.com/r/emacs/comments/64xb3q/killthisbuffer_sometimes_just_stops_working/."
  (interactive)
  (if (minibufferp)
      (abort-recursive-edit)
    (kill-buffer (current-buffer))))

(defvar +lisp-modes
  '(emacs-lisp-mode
    lisp-interaction-mode
    eshell-mode
    clojure-mode
    lisp-mode)
  "List for all used lisp modes.")

;;;###autoload
(defun close-minibuffer ()
  "Close the current buffer if its major mode is in the `modes` list."
  (interactive)
  (unless (memq major-mode interactive-modes-alist)
    (progn
      (kill-buffer (current-buffer))
      (unless (one-window-p)
        (delete-window)))
    (message (format "Closing %s ..." major-mode))))

;;;###autoload
(defun +kill-window (&optional args)
  "Kill the current buffer and then delete the current window."
  (interactive)
  (if (one-window-p)
      (+kill-this-buffer)
    ;; else
    (when (buffer-unique-p)
      (+kill-this-buffer))
    (when args
      (delete-window))))

(defun kill-other-buffers ()
  "Kill all other buffers."
  (interactive)
  (mapc 'kill-buffer (delq (current-buffer) (buffer-list))))

;;;###autoload
(defun manual-save-buffer ()
  "Save buffer and remove trailing whitespace.
this method is necessary (instead of overwriting the default) to avoid messing
with auto-save behavior."
  (interactive)
  (delete-trailing-whitespace)
  (save-buffer))

;;;###autoload
(defun really-kill-current-buffer ()
  "Kill the current buffer - even if modified.
Useful to use on stuck buffers opened with `emacsclient'"
  (interactive)
  (set-buffer-modified-p nil)
  (read-only-mode -1)
  (let ((buf-name (buffer-name)))
    (when (string-match "/" buf-name)
      (setq buf-name (replace-regexp-in-string "/" "-" buf-name)))
    ;; setq buf-name (replace "/" with "-")
    (write-file (make-temp-file (concat "/tmp/emacs/" buf-name))))
  (kill-buffer (current-buffer)))

(defun insert-or-update-header-footer ()
  "Insert or update the header and footer of the current file."
  (interactive)
  (let* ((file-name (file-name-nondirectory (buffer-file-name)))
         (header (concat (format ";;; %s " file-name)
                         "---  desc  -*- lexical-binding: t; -*-\n"
                         ";;; Commentary:\n;;; Code:\n"))
         (footer (format ";;; %s ends here" file-name)))
    (save-excursion
      (goto-char (point-min))
      (if (re-search-forward (regexp-quote header) nil t)
          (replace-match header)
        (insert header "\n"))
      (goto-char (point-max))
      (if (re-search-backward (regexp-quote footer) nil t)
          (replace-match footer)
        (insert "\n" footer)))
    (message "Header and footer updated in %s" file-name)))

(defun ju-hash-to-list (HashTable)
  (let ((xx nil))
    (maphash
     (lambda (k v)
       (push (list  k v) xx))
     HashTable)
    xx))

(defmacro cmds! (&rest branches)
  "Returns a dispatcher that runs the a command in BRANCHES.
Meant to be used as a target for keybinds (e.g. with `define-key' or `general-def').

BRANCHES is a flat list of CONDITION COMMAND pairs. CONDITION is a lisp form
that is evaluated when (and each time) the dispatcher is invoked. If it returns
non-nil, COMMAND is invoked, otherwise it falls through to the next pair.

The last element of BRANCHES can be a COMMANd with no CONDITION. This acts as
the fallback if all other conditions fail.

Otherwise, Emacs will fall through the keybind and search the next keymap for a
keybind (as if this keybind never existed).

See `general-key-dispatch' for what other arguments it accepts in BRANCHES."
  (declare (doc-string 1))
  (let ((docstring (if (stringp (car branches)) (pop branches) ""))
        fallback)
    (when (cl-oddp (length branches))
      (setq fallback (car (last branches))
            branches (butlast branches)))
    (let ((defs (cl-loop for (key value) on branches by 'cddr
                         unless (keywordp key)
                         collect (list key value))))
      `'(menu-item
         ,(or docstring "") nil
         :filter (lambda (&optional _)
                   (let (it)
                     (cond ,@(mapcar (lambda (pred-def)
                                       `((setq it ,(car pred-def))
                                         ,(cadr pred-def)))
                                     defs)
                           (t ,fallback))))))))

(defmacro first-arg! (arg)
  `(if (string-match ,`(format "\\b\\(%s\\)\\b" ,arg) ,arg)
       (match-string 1 ,arg)))

(defmacro first-word! (arg)
  `(if (string-match ,`(format "\\b\\(%s\\).*" ,arg) ,arg)
       (match-string 1 ,arg)))

(defmacro symbol-or-self! (val)
  `(if ,(ignore-error (symbol-name val))
       (symbol-name ,val)
     ,val))

;;;###autoload
(defvar ju--counter 0
  "counter to use to prevent name clashes for automatically named functions.")

;;;###autoload
(defmacro ju--ensure-lists (&rest vars)
  "Ensure that all variables in VARS are lists if they are not already.
If any variable is a lambda, it will not be considered to be a list. If a var is
nil, it will be set to (list nil)."
  `(progn
     ,@(mapcar (lambda (var)
                 `(unless (and ,var
                               (listp ,var)
                               ;; lambdas are lists
                               (not (functionp ,var)))
                    (setq ,var (list ,var))))
               vars)))

;;;###autoload
(defun ju--define-transient-function (function hook &optional advice
                                               condition)
  "Define and return a modified FUNCTION that removes itself from HOOK.
The new function will automatically remove itself from HOOK after the first time
it is called. If ADVICE is non-nil, HOOK should specify a function to advise
instead. If CONDITION is a function, only remove the function if calling
CONDITION on the return value returns true. For example, if CONDITION is
#'identity, only remove the function if it returns non-nil."
  (let ((name (intern (format "general--transient-%s%s%s"
                              (if (symbolp function)
                                  (symbol-name function)
                                ;; lambda; name with counter
                                (cl-incf ju--counter))
                              (if advice
                                  "-for-advice"
                                "-for-hook")
                              (if (functionp condition)
                                  (if (symbolp function)
                                      (format "-on-%s" condition)
                                    ;; lambda; name with counter
                                    (format "-on-lambda-%s"
                                            (cl-incf ju--counter)))
                                "")))))
    (defalias name
      (if advice
          (lambda (&rest args)
            (let ((res (apply function args)))
              (when (or (not (functionp condition)) (funcall condition res))
                (advice-remove hook name)
                (fmakunbound name))
              res))
        (lambda (&rest args)
          (let ((res (apply function args)))
            (when (or (not (functionp condition)) (funcall condition res))
              (remove-hook hook name)
              (fmakunbound name))
            res)))
      (format "Call %s with ARGS and then remove it from `%s'%s."
              (if (symbolp function)
                  (format "`%s'" function)
                ;; TODO put full lambda in docstring or use backquote instead of
                ;; relying on lexical-binding (so full lambda is in definition)
                "given lambda")
              hook
              (if (functionp condition)
                  (format " once calling %s on the return value succeeds."
                          (if (symbolp condition)
                              condition
                            "given lambda"))
                "")))
    name))

;;;###autoload
(defun ju-add-hook (hooks functions &optional append local transient)
  "A drop-in replacement for `add-hook'.
Unlike `add-hook', HOOKS and FUNCTIONS can be single items or lists. APPEND and
LOCAL are passed directly to `add-hook'. When TRANSIENT is non-nil, each
function will remove itself from the hook it is in after it is run once. If
TRANSIENT is a function, call it on the return value in order to determine
whether to remove a function from the hook. For example, if TRANSIENT is
#'identity, remove each function only if it returns non-nil. TRANSIENT could
alternatively check something external and ignore the function's return value."
  (ju--ensure-lists hooks functions)
  (dolist (hook hooks)
    (dolist (func functions)
      (when transient
        (setq func (ju--define-transient-function
                    func hook nil transient)))
      (add-hook hook func append local))))

;;;###autoload
(defun ju-remove-hook (hooks functions &optional local)
  "A drop-in replacement for `remove-hook'.
Unlike `remove-hook', HOOKS and FUNCTIONS can be single items or lists. LOCAL is
passed directly to `remove-hook'."
  (ju--ensure-lists hooks functions)
  (dolist (hook hooks)
    (dolist (func functions)
      (remove-hook hook func local))))

;;;###autoload
(defmacro ju-after-gui (&rest body)
  "Run BODY once after the first GUI frame is created."
  (declare (indent 0) (debug t))
  `(if (and (not (daemonp)) (display-graphic-p))
       (progn ,@body)
     (ju-add-hook 'server-after-make-frame-hook
                  (lambda ()
                    (when (display-graphic-p)
                      ,@body
                      t))
                  nil
                  nil
                  #'identity)))

(defmacro ju-after-tty (&rest body)
  "Run BODY once after the first terminal frame is created."
  (declare (indent 0) (debug t))
  `(if (and (not (daemonp)) (not (display-graphic-p)))
       (progn ,@body)
     (ju-add-hook 'server-after-make-frame-hook
                  (lambda ()
                    (unless (display-graphic-p)
                      ,@body
                      t))
                  nil
                  nil
                  #'identity)))

;;;###autoload
(defmacro ju-after-init (&rest body)
  "Run BODY after emacs initialization.
If after emacs initialization already, run BODY now."
  (declare (indent 0) (debug t))
  `(if after-init-time
       (progn ,@body)
     (ju-add-hook 'after-init-hook (lambda () ,@body))))
        #+end_src

*** Load Path
:PROPERTIES:
:header-args: :noweb-ref core-load-path-cfg
:END:

#+BEGIN_SRC elisp :tangle core/core-load-paths.el :noweb-ref :noweb yes
;; -*- lexical-binding: t; -*-

<<core-load-path-cfg>>

(provide 'core-load-paths)
;;; core-load-paths.el ends here.
#+END_SRC


#+begin_src elisp
(require 'core-lib)

(defvar emacs-dir
  user-emacs-directory
  "Path where Emacs loaded (e.g. $HOME/.emacs.d/ or $HOME/.config/emacs).")

(defun expand-user-emacs-file (file)
  "Expand relative FILE to `user-emacs-directory'."
  (expand-file-name file (file-name-directory emacs-dir)))

(defvar user-notes-dir (expand "~/notes/"))

;; TODO: Move to org handler

(defconst IS-MAC      (eq system-type 'darwin))
(defconst IS-LINUX    (memq system-type '(gnu gnu/linux gnu/kfreebsd berkeley-unix)))
(defconst IS-WINDOWS  (memq system-type '(cygwin windows-nt ms-dos)))

(defvar user-dir
  (expand-file-name
   (if-let (cfg-dir (getenv-internal "USER_SYNC_DIR"))
       (file-name-as-directory cfg-dir)
     (or (let ((xdg-dir
                (file-name-concat
                 (or (getenv-internal "HOME")
                     "~")
                 "~/.emacs.d/")))
           (if (file-directory-p xdg-dir) xdg-dir))
         "~/.emacs_cfg.d/")))
  "Where your private configuration is placed.

  It will be $USER_SYNC_DIR, ~/sync/emacs/ or ~/.emacs/,
depends on what is found first Must end in a slash.")

(defvar config-dir (expand-file-name
                    (let ((xdg-dir
                           (or (getenv-internal "XDG_CONFIG_HOME")
                               "~/.config")))
                      (if (file-directory-p xdg-dir) xdg-dir))))

(defconst core-dir
  (file-name-directory load-file-name))

(defconst sync-dir
  (if-let (cfg-dir (getenv-internal "USER_SYNC_DIR"))
      (file-name-as-directory cfg-dir)
    (or (let ((xdg-dir
               (file-name-concat
                (or (getenv-internal "HOME")
                    "~")
                "sync/")))
          (if (file-directory-p xdg-dir) xdg-dir)))))

(defvar cache-dir
  (expand-file-name "emacs/" (or (getenv-internal "XDG_CACHE_HOME") "~/.cache")))

(defvar tmp-dir
  (if IS-WINDOWS
      (expand-file-name "emacs/tmp/" (getenv-internal "TEMP"))
    (expand-file-name "/tmp/emacs/")))

(make-dir! cache-dir)
(make-dir! tmp-dir)
#+end_src

*** Indent
:PROPERTIES:
:header-args: :noweb-ref core-indent-cfg
:END:

#+BEGIN_SRC elisp :tangle core/core-indent.el :noweb-ref :noweb yes
;; -*- lexical-binding: t; -*-

<<core-indent-cfg>>

(provide 'core-indent)
;;; core-indent.el ends here.
#+END_SRC

#+begin_src elisp
(advice-add #'calculate-lisp-indent :override #'void~calculate-lisp-indent)

(defun void~calculate-lisp-indent (&optional parse-start)
  "Add better indentation for quoted and backquoted lists."
  ;; This line because `calculate-lisp-indent-last-sexp` was defined with `defvar`
  ;; with it's value ommited, marking it special and only defining it locally. So
  ;; if you don't have this, you'll get a void variable error.
  (defvar calculate-lisp-indent-last-sexp)
  (save-excursion
    (beginning-of-line)
    (let ((indent-point (point))
          state
          ;; setting this to a number inhibits calling hook
          (desired-indent nil)
          (retry t)
          calculate-lisp-indent-last-sexp containing-sexp)
      (cond ((or (markerp parse-start) (integerp parse-start))
             (goto-char parse-start))
            ((null parse-start) (beginning-of-defun))
            (t (setq state parse-start)))
      (unless state
        ;; Find outermost containing sexp
        (while (< (point) indent-point)
          (setq state (parse-partial-sexp (point) indent-point 0))))
      ;; Find innermost containing sexp
      (while (and retry
                  state
                  (> (elt state 0) 0))
        (setq retry nil)
        (setq calculate-lisp-indent-last-sexp (elt state 2))
        (setq containing-sexp (elt state 1))
        ;; Position following last unclosed open.
        (goto-char (1+ containing-sexp))
        ;; Is there a complete sexp since then?
        (if (and calculate-lisp-indent-last-sexp
                 (> calculate-lisp-indent-last-sexp (point)))
            ;; Yes, but is there a containing sexp after that?
            (let ((peek (parse-partial-sexp calculate-lisp-indent-last-sexp
                                            indent-point 0)))
              (if (setq retry (car (cdr peek))) (setq state peek)))))
      (if retry
          nil
        ;; Innermost containing sexp found
        (goto-char (1+ containing-sexp))
        (if (not calculate-lisp-indent-last-sexp)
            ;; indent-point immediately follows open paren.
            ;; Don't call hook.
            (setq desired-indent (current-column))
          ;; Find the start of first element of containing sexp.
          (parse-partial-sexp (point) calculate-lisp-indent-last-sexp 0 t)
          (cond ((looking-at "\\s(")
                 ;; First element of containing sexp is a list.
                 ;; Indent under that list.
                 )
                ((> (save-excursion (forward-line 1) (point))
                    calculate-lisp-indent-last-sexp)
                 ;; This is the first line to start within the containing sexp.
                 ;; It's almost certainly a function call.
                 (if (or
                      ;; Containing sexp has nothing before this line
                      ;; except the first element. Indent under that element.
                      (= (point) calculate-lisp-indent-last-sexp)

                      ;; First sexp after `containing-sexp' is a keyword. This
                      ;; condition is more debatable. It's so that I can have
                      ;; unquoted plists in macros. It assumes that you won't
                      ;; make a function whose name is a keyword.
                      ;; (when-let (char-after (char-after (1+ containing-sexp)))
                      ;;   (char-equal char-after ?:))

                      ;; Check for quotes or backquotes around.
                      (let* ((positions (elt state 9))
                             (last (car (last positions)))
                             (rest (reverse (butlast positions)))
                             (any-quoted-p nil)
                             (point nil))
                        (or
                         (when-let (char (char-before last))
                           (or (char-equal char ?')
                               (char-equal char ?`)))
                         (progn
                           (while (and rest (not any-quoted-p))
                             (setq point (pop rest))
                             (setq any-quoted-p
                                   (or
                                    (when-let (char (char-before point))
                                      (or (char-equal char ?')
                                          (char-equal char ?`)))
                                    (save-excursion
                                      (goto-char (1+ point))
                                      (looking-at-p
                                       "\\(?:back\\)?quote[\t\n\f\s]+(")))))
                           any-quoted-p))))
                     ;; Containing sexp has nothing before this line
                     ;; except the first element.  Indent under that element.
                     nil
                   ;; Skip the first element, find start of second (the first
                   ;; argument of the function call) and indent under.
                   (progn (forward-sexp 1)
                          (parse-partial-sexp (point)
                                              calculate-lisp-indent-last-sexp
                                              0 t)))
                 (backward-prefix-chars))
                (t
                 ;; Indent beneath first sexp on same line as
                 ;; `calculate-lisp-indent-last-sexp'.  Again, it's
                 ;; almost certainly a function call.
                 (goto-char calculate-lisp-indent-last-sexp)
                 (beginning-of-line)
                 (parse-partial-sexp (point) calculate-lisp-indent-last-sexp
                                     0 t)
                 (backward-prefix-chars)))))
      ;; Point is at the point to indent under unless we are inside a string.
      ;; Call indentation hook except when overridden by lisp-indent-offset
      ;; or if the desired indentation has already been computed.
      (let ((normal-indent (current-column)))
        (cond ((elt state 3)
               ;; Inside a string, don't change indentation.
               nil)
              ((and (integerp lisp-indent-offset) containing-sexp)
               ;; Indent by constant offset
               (goto-char containing-sexp)
               (+ (current-column) lisp-indent-offset))
              ;; in this case calculate-lisp-indent-last-sexp is not nil
              (calculate-lisp-indent-last-sexp
               (or
                ;; try to align the parameters of a known function
                (and lisp-indent-function
                     (not retry)
                     (funcall lisp-indent-function indent-point state))
                ;; If the function has no special alignment
                ;; or it does not apply to this argument,
                ;; try to align a constant-symbol under the last
                ;; preceding constant symbol, if there is such one of
                ;; the last 2 preceding symbols, in the previous
                ;; uncommented line.
                (and (save-excursion
                       (goto-char indent-point)
                       (skip-chars-forward " \t")
                       (looking-at ":"))
                     ;; The last sexp may not be at the indentation
                     ;; where it begins, so find that one, instead.
                     (save-excursion
                       (goto-char calculate-lisp-indent-last-sexp)
                       ;; Handle prefix characters and whitespace
                       ;; following an open paren.  (Bug#1012)
                       (backward-prefix-chars)
                       (while (not (or (looking-back "^[ \t]*\\|([ \t]+"
                                                     (line-beginning-position))
                                       (and containing-sexp
                                            (>= (1+ containing-sexp) (point)))))
                         (forward-sexp -1)
                         (backward-prefix-chars))
                       (setq calculate-lisp-indent-last-sexp (point)))
                     (> calculate-lisp-indent-last-sexp
                        (save-excursion
                          (goto-char (1+ containing-sexp))
                          (parse-partial-sexp (point) calculate-lisp-indent-last-sexp 0 t)
                          (point)))
                     (let ((parse-sexp-ignore-comments t)
                           indent)
                       (goto-char calculate-lisp-indent-last-sexp)
                       (or (and (looking-at ":")
                                (setq indent (current-column)))
                           (and (< (line-beginning-position)
                                   (prog2 (backward-sexp) (point)))
                                (looking-at ":")
                                (setq indent (current-column))))
                       indent))
                ;; another symbols or constants not preceded by a constant
                ;; as defined above.
                normal-indent))
              ;; in this case calculate-lisp-indent-last-sexp is nil
              (desired-indent)
              (t
               normal-indent))))))
#+end_src

*** Window
:PROPERTIES:
:header-args: :noweb-ref core-window-cfg
:END:

#+BEGIN_SRC elisp :tangle core/core-window.el :noweb-ref :noweb yes
;; -*- lexical-binding: t; -*-

<<core-window-cfg>>

(provide 'core-window)
;;; core-window.el ends here.
#+END_SRC

#+begin_src elisp
(defmacro core-match-major-mode (mode)
  "Create a function that return whether the current `major-mode' is MODE."
  (let ((name (intern (format "core-match-%s" mode))))
    `(progn
       (defun ,name (buffer-or-name _action)
         (ignore-errors
           (let ((buffer (get-buffer buffer-or-name)))
             (eq ',mode (buffer-local-value 'major-mode buffer)))))
       #',name)))

(defun core-display-and-select-buffer (func buffer alist)
  "Call FUNC with BUFFER and ALIST.
Select the window afterwards if possible. This is modified from
`shackle--display-buffer-reuse'. Additionally set the window to be fixed size."
  (let ((window (funcall func buffer alist)))
    (when (and window (window-live-p window))
      (select-window window t))
    ;; TODO this breaks slots; doesn't work for non-side windows
    ;; (with-current-buffer buffer
    ;;   (setq window-size-fixed t))
    window))

(defun core-display-buffer-reuse-window (buffer alist)
  "Call `display-buffer-reuse-window' with BUFFER and ALIST.
Select the window afterwards if possible."
  (core-display-and-select-buffer #'display-buffer-reuse-window buffer alist))

(defun core-display-buffer-in-side-window (buffer alist)
  "Call `display-buffer-in-side-window' with BUFFER and ALIST.
Select the window afterwards if possible."
  (core-display-and-select-buffer #'display-buffer-in-side-window buffer alist))

(defun core-display-buffer-in-side-window-no-header (buffer alist)
  "`core-display-buffer-in-side-window' but don't have a header line.
Having a header line in some buffers will cause text to be cut off at the
bottom (e.g. transient and frog menu)."
  (core-display-buffer-in-side-window buffer alist)
  (setf (buffer-local-value 'header-line-format buffer) nil))

(defun core-display-buffer-same-window (buffer alist)
  "Call `display-buffer-same-window' with BUFFER and ALIST.
Select the window afterwards if possible."
  (core-display-and-select-buffer #'display-buffer-same-window buffer alist))

(defun shackle--split-some-window (frame alist)
  "Return a window if splitting any window was successful.
This function tries using the largest window on FRAME for
splitting, if all windows are the same size, the selected one is
taken, in case this fails, the least recently used window is used
for splitting.  ALIST is passed to `window--try-to-split-window'
internally."
  (or (window--try-to-split-window (get-largest-window frame t) alist)
      (window--try-to-split-window (get-lru-window frame t) alist)))

(defun shackle--display-buffer-popup-window (buffer alist)
  "Display BUFFER in a popped up window.
This is a stripped down version of `shackle--display-buffer-popup-window'.
ALIST is passed to `shackle--window-display-buffer' internally.
If PLIST contains the :other key with t as value, reuse the next
available window if possible."
  (let ((window (if (not (one-window-p))
                    (next-window nil 'nominibuf)
                  (shackle--split-some-window (selected-frame) alist))))
    (window--display-buffer buffer window 'window alist)))

(defun core-display-buffer-creating-other-window (buffer alist)
  "Call `display-buffer-in-other-window' with BUFFER and ALIST.
If another window does not exist, create it. Select the window afterwards if
possible."
  (core-display-and-select-buffer #'shackle--display-buffer-popup-window
                                  buffer alist))

(defmacro core-handle-window (condition &rest body)
  "Display windows matching CONDITION with the settings in BODY."
  (declare (indent 1) (debug t))
  (let ((condition (if (and (symbolp condition)
                            (string-match "-mode$" (symbol-name condition)))
                       `(core-match-major-mode ,condition)
                     condition)))
    `(cl-pushnew
      (list ,condition ,@body)
      display-buffer-alist
      :test 'equal)))

(defmacro core-handle-popup (condition &optional slot)
  "Display popups matching CONDITION in a side window at the top.
When SLOT is non-nil, display popup buffers in that SLOT in the side window."
  `(core-handle-window ,condition
     '(core-display-buffer-reuse-window core-display-buffer-in-side-window)
     '(side . bottom)
     '(slot . ,slot)
     '(window-height . 0.4)))

(defmacro +handle-popup (condition &optional aside height)
  "Display popups matching CONDITION in a side window at the top.
When SLOT is non-nil, display popup buffers in that SLOT in the side window."
  `(core-handle-window ,condition
     '(core-display-buffer-reuse-window core-display-buffer-in-side-window)
     '(side . ,(if aside 'right 'bottom))
     '(window-height . ,(if height height 0.4))))

(defmacro core-handle-popup-aside-right (condition &optional slot)
  "Display popups matching CONDITION in a side window at the top.
When SLOT is non-nil, display popup buffers in that SLOT in the side window."
  `(core-handle-window ,condition
     '(core-display-buffer-reuse-window core-display-buffer-in-side-window)
     '(side . right)
     '(slot . ,slot)
     '(window-height . 0.4)))

(defmacro core-handle-popup-no-header (condition &optional slot)
  "Display popups matching CONDITION in a side window at the top.
Remove the header line, this handles some buffers where text
would be cut off when there is a header line.  When SLOT is
non-nil, display popup buffers in that SLOT in the side window."
  `(core-handle-window ,condition
     '(core-display-buffer-reuse-window
       core-display-buffer-in-side-window-no-header)
     '(side . bottom)
     '(slot . ,slot)
     '(window-height . 0.4)))

(defmacro core-handle-popup-same-window (condition)
  "Display popups matching CONDITION in the current window."
  `(core-handle-window ,condition
     '(core-display-buffer-reuse-window core-display-buffer-same-window)))

(defmacro core-handle-popup-other-window (condition)
  "Display popups matching CONDITION in the other window.
Create another window if one doesn't exist"
  `(core-handle-window ,condition
     '(core-display-buffer-reuse-window
       core-display-buffer-creating-other-window)))

(defmacro core-handle-popup-other-window-no-select (condition)
  "Display popups matching CONDITION in the other window without selecting it.
Create another window if one doesn't exist"
  `(core-handle-window ,condition
     'shackle--display-buffer-popup-window))

(defun side-window-p ()
  "Return non-nil if the selected window is a side window."
  (window-parameter (selected-window) 'window-side))
#+end_src

*** Tangle
:PROPERTIES:
:header-args: :noweb-ref core-tangle-cfg
:END:

#+BEGIN_SRC elisp :tangle core/core-tangle.el :noweb-ref :noweb yes
;; -*- lexical-binding: t; -*-

<<core-tangle-cfg>>

(provide 'core-tangle)
;;; core-tangle.el ends here.
#+END_SRC

#+begin_src elisp
(require 'core-lib)
(require 'core-load-paths)
(require 'org)

(defvar loaded-ok nil)

(defun load-config (&optional stable-only)
  "Check config files available and load the most complete.
STABLE-ONLY means that won't load config.el"
  (interactive)

  (if (file-exists-p config-stable-file)
      (load! config-stable-base-file)
    (unless (bound-and-true-p stable-only)
      (load! config-base-file))))

(defun tangle-config-and-load ()
  (interactive)

  (condition-case err
      (progn
        (org-babel-tangle-file config-org-file)
        (load config-tangled-file nil t)
        (setq loaded-ok t))
    ;; Load stable file (for debug) or file with errors to load what it can
    (progn
      (load-config)
      (error err)))

  (when (bound-and-true-p loaded-ok)
    (delete-file config-stable-file t)
    (copy-file config-tangled-file config-stable-file)
    (silently! (byte-compile-file config-stable-file))
    (load-config t)))
#+end_src

*** Security
:PROPERTIES:
:header-args: :noweb-ref core-security-cfg
:END:

#+BEGIN_SRC elisp :tangle core/core-security.el :noweb-ref :noweb yes
;; -*- lexical-binding: t; -*-

<<core-security-cfg>>

(provide 'core-security)
;;; core-security.el ends here.
#+END_SRC

#+begin_src elisp
(setq gnutls-verify-error noninteractive
      gnutls-algorithm-priority
      (when (boundp 'libgnutls-version)
        (concat "SECURE128:+SECURE192:-VERS-ALL"
                (if (and (not IS-WINDOWS)
                         (>= libgnutls-version 30605))
                    ":+VERS-TLS1.3")
                ":+VERS-TLS1.2"))
      ;; `gnutls-min-prime-bits' is set based on recommendations from
      ;; https://www.keylength.com/en/4/
      gnutls-min-prime-bits 3072
      tls-checktrust gnutls-verify-error
      ;; Emacs is built with gnutls.el by default, so `tls-program' won't
      ;; typically be used, but in the odd case that it does, we ensure a more
      ;; secure default for it (falling back to `openssl' if absolutely
      ;; necessary). See https://redd.it/8sykl1 for details.
      tls-program '("openssl s_client -connect %h:%p -CAfile \
 %t -nbio -no_ssl3 -no_tls1 -no_tls1_1 -ign_eof"
                    "gnutls-cli -p %p --dh-bits=3072 --ocsp --x509cafile=%t \
--strict-tofu --priority='SECURE192:+SECURE128:-VERS-ALL:+VERS-TLS1.2:+VERS-TLS1.3' %h"
                    ;; compatibility fallbacks
                    "gnutls-cli -p %p %h"))
#+end_src

*** Popup handler
:PROPERTIES:
:header-args: :noweb-ref popup-handler-cfg
:END:

#+BEGIN_SRC elisp :tangle core/popup-handler.el :noweb-ref :noweb yes
;; -*- lexical-binding: t; -*-

<<popup-handler-cfg>>

(provide 'popup-handler)
;;; popup-handler.el ends here.
#+END_SRC

#+begin_src elisp
(require 'core-packages)

(use-package on
  :ensure (:host github :repo "ajgrf/on.el")
  :demand t)

(defvar noct-elisp-scratch-hook nil
  "Hook run when scratch buffer switches from fundamental to emacs-lisp mode.
Can't use `after-change-major-mode-hook' hook since that triggers during init.")

;; TODO remove other after one is called
(defmacro noct-after-buffer (&rest body)
  "Run BODY once after switching buffers or when finding a file.
Doom uses a lot. Additionally run once in `noct-elisp-scratch-hook', so
BODY run if I switch the scratch buffer to elisp."
  (declare (indent defun))
  `(let ((fun (lambda (&rest _)
                ,@body)))
     (general-add-hook '(on-switch-buffer-hook
                         noct-elisp-scratch-hook) fun nil nil t)
     (general-add-advice 'after-find-file :before fun nil t)))


(defmacro noct-match-major-mode (mode)
  "Create a function that returns whether the current `major-mode' is MODE."
  (let ((name (intern (format "noct-match-%s" mode))))
    `(progn
       (defun ,name (buffer-or-name _action)
         (ignore-errors
           (let ((buffer (get-buffer buffer-or-name)))
             (eq ',mode (buffer-local-value 'major-mode buffer)))))
       #',name)))

(defun noct-display-and-select-buffer (func buffer alist)
  "Call FUNC with BUFFER and ALIST.
Select the window afterwards if possible. This is modified from
`shackle--display-buffer-reuse'. Additionally set the window to be fixed size."
  (let ((window (funcall func buffer alist)))
    (when (and window (window-live-p window))
      (select-window window t))
    ;; TODO this breaks slots; doesn't work for non-side windows
    ;; (with-current-buffer buffer
    ;;   (setq window-size-fixed t))
    window))

(defun noct-display-buffer-reuse-window (buffer alist)
  "Call `display-buffer-reuse-window' with BUFFER and ALIST.
Select the window afterwards if possible."
  (noct-display-and-select-buffer #'display-buffer-reuse-window buffer alist))

(defun noct-display-buffer-in-side-window (buffer alist)
  "Call `display-buffer-in-side-window' with BUFFER and ALIST.
Select the window afterwards if possible."
  (noct-display-and-select-buffer #'display-buffer-in-side-window buffer alist))

(defun noct-display-buffer-in-side-window-no-header (buffer alist)
  "`noct-display-buffer-in-side-window' but don't have a header line.
Having a header line in some buffers will cause text to be cut off at the
bottom (e.g. transient and frog menu)."
  (noct-display-buffer-in-side-window buffer alist)
  (setf (buffer-local-value 'header-line-format buffer) nil))

(defun noct-display-buffer-same-window (buffer alist)
  "Call `display-buffer-same-window' with BUFFER and ALIST.
Select the window afterwards if possible."
  (noct-display-and-select-buffer #'display-buffer-same-window buffer alist))

(defun shackle--split-some-window (frame alist)
  "Return a window if splitting any window was successful.
This function tries using the largest window on FRAME for
splitting, if all windows are the same size, the selected one is
taken, in case this fails, the least recently used window is used
for splitting.  ALIST is passed to `window--try-to-split-window'
internally."
  (or (window--try-to-split-window (get-largest-window frame t) alist)
      (window--try-to-split-window (get-lru-window frame t) alist)))

(defun shackle--display-buffer-popup-window (buffer alist)
  "Display BUFFER in a popped up window.
This is a stripped down version of `shackle--display-buffer-popup-window'.
ALIST is passed to `shackle--window-display-buffer' internally.
If PLIST contains the :other key with t as value, reuse the next
available window if possible."
  (let ((window (if (not (one-window-p))
                    (next-window nil 'nominibuf)
                  (shackle--split-some-window (selected-frame) alist))))
    (window--display-buffer buffer window 'window alist)))

(defun noct-display-buffer-creating-other-window (buffer alist)
  "Call `display-buffer-in-other-window' with BUFFER and ALIST.
If another window does not exist, create it. Select the window afterwards if
possible."
  (noct-display-and-select-buffer #'shackle--display-buffer-popup-window
                                  buffer alist))

(defmacro noct-handle-window (condition &rest body)
  "Display windows matching CONDITION with the settings in BODY."
  (declare (indent 1) (debug t))
  (let ((condition (if (and (symbolp condition)
                            (string-match "-mode$" (symbol-name condition)))
                       `(noct-match-major-mode ,condition)
                     condition)))
    `(cl-pushnew
      (list ,condition ,@body)
      display-buffer-alist
      :test 'equal)))

(defmacro noct-handle-popup (condition &optional slot side size)
  "Display popups matching CONDITION in a side window at the top.
When SLOT is non-nil, display popup buffers in that SLOT in the side window."
  `(noct-handle-window ,condition
     '(noct-display-buffer-reuse-window noct-display-buffer-in-side-window)
     '(side . ,(if side side 'bottom))
     '(slot . ,slot)
     '(window-height . ,(if size size 0.4))))

(defmacro noct-handle-popup-no-header (condition &optional slot)
  "Display popups matching CONDITION in a side window at the top.
Remove the header line. This handles some buffers where text would be cut off
when there is a header line. When SLOT is non-nil, display popup buffers in that
SLOT in the side window."
  `(noct-handle-window ,condition
     '(noct-display-buffer-reuse-window
       noct-display-buffer-in-side-window-no-header)
     '(side . bottom)
     '(slot . ,slot)
     '(window-height . 0.3)))

(defmacro noct-handle-popup-same-window (condition)
  "Display popups matching CONDITION in the current window."
  `(noct-handle-window ,condition
     '(noct-display-buffer-reuse-window noct-display-buffer-same-window)))

(defmacro noct-handle-popup-other-window (condition)
  "Display popups matching CONDITION in the other window.
Create another window if one doesn't exist"
  `(noct-handle-window ,condition
     '(noct-display-buffer-reuse-window
       noct-display-buffer-creating-other-window)))

(defmacro noct-handle-popup-other-window-no-select (condition)
  "Display popups matching CONDITION in the other window without selecting it.
Create another window if one doesn't exist"
  `(noct-handle-window ,condition
     'shackle--display-buffer-popup-window))

(defun noct-side-window-p ()
  "Return non-nil if the selected window is a side window."
  (window-parameter (selected-window) 'window-side))
#+end_src

*** Compilation
:PROPERTIES:
:header-args: :noweb-ref core-compilation-cfg
:END:

#+BEGIN_SRC elisp :tangle core/core-compilation.el :noweb-ref :noweb yes
;; -*- lexical-binding: t; -*-

<<core-compilation-cfg>>

(provide 'core-compilation)
;;; core-compilation.el ends here.
#+END_SRC

#+begin_src elisp
(require 'cl-lib)
(require 'subr-x)
(require 'bytecomp)

(defvar e--last-emacs-version ""
  "This variable is set during Emacs initialization to its version.")
(defconst e--last-emacs-version-file
  (expand-file-name (concat cache-dir "last-emacs-version"))
  "File that sets `--last-emacs-version' variable.")

(cl-defun e//dir-byte-compile-state (dir &optional update)
  "Get the directory byte-compile state.
When the UPDATE is t, it will force update the state."
  (let ((state (gethash dir e--dir-byte-compile-status)))
    (when (and (not update) state)
      (cl-return-from e//dir-byte-compile-state state))
    (setq state nil)
    (remhash dir e--dir-byte-compile-status)
    (let ((afiles '())
          (slist (mapcan
                  (lambda (x)
                    (mapcar (lambda (y) (concat x y)) load-file-rep-suffixes))
                  (list ".el" (byte-compile-dest-file ".el")))))
      (cl-dolist (file (directory-files-recursively dir "\\.elc?\\(\\.gz\\)?$"))
        (let* ((name (file-name-sans-extension file))
               (paths (alist-get name afiles nil nil 'equal)))
          (unless paths
            (setq paths (list nil nil nil nil))
            (push (cons name paths) afiles))
          (if-let ((idx (cl-loop for i from 0
                                 for s in slist
                                 until (string-suffix-p s file)
                                 finally return i)))
              (setf (nth idx paths) file))))
      (cl-dolist (item (mapcar 'cdr afiles))
        (let ((el (or (nth 0 item) (nth 1 item)))   ; .el or .el.gz file
              (elc (or (nth 2 item) (nth 3 item)))) ; .elc or .elc.gz file
          (pcase nil
            ((guard (null el))            ; *.el not exists
             (puthash dir -1 e--dir-byte-compile-status)
             (cl-return-from e//dir-byte-compile-state -1))
            ((guard (null elc))           ; *.elc not exists
             (when (null state)
               (setq state 0)))
            ((guard (file-newer-than-file-p el elc)) ; *.elc is older
             (puthash dir -1 e--dir-byte-compile-status)
             (cl-return-from e//dir-byte-compile-state -1))
            (_
             (setq state 1)))))
      (puthash dir state e--dir-byte-compile-status)
      state)))

(defun e//remove-byte-compiled-files-in-dir (dir)
  "Remove all .elc files in DIR directory."
  (dolist (elc (directory-files-recursively dir "\\.elc\\(\\.gz\\)?$"))
    (when (file-exists-p elc)
      (delete-file elc))))

(defvar e--dir-byte-compile-status
  (make-hash-table :test 'equal)
  "The hash table to store each directory byte compile state.
nil for un-initialized, -1 for stale or orphaned *.elc,
0 for no *.elc, 1 for *.elc corresponding to *.el.")

(defun e//update-last-emacs-version ()
  "Update `e--last-emacs-version' and its saved value."
  (with-temp-file e--last-emacs-version-file
    (insert (format "(setq --last-emacs-version %S)"
                    (setq e--last-emacs-version emacs-version)))
    (make-directory (file-name-directory e--last-emacs-version-file)
                    t)))


(defun emacs-version-synced-p ()
  (string= e--last-emacs-version emacs-version))

(defun e--became-stale-p ()
  (defun e--check-eln-dir ()
    (e//dir-byte-compile-state
     (concat cache-dir "eln/")))
  (> 0 (if (not (e--check-eln-dir))
           0
         (e--check-eln-dir))))

(when (and (featurep 'native-compile)
           (not (native-comp-available-p)))
  (delq 'native-compile features))

;; Native compilation support (see http://akrl.sdf.org/gccemacs.html)
(when (boundp 'native-comp-eln-load-path)
  ;; REVIEW Use `startup-redirect-eln-cache' when 28 support is dropped
  (add-to-list 'native-comp-eln-load-path
               (expand-file-name "eln/" cache-dir))

  ;; UX: Suppress compiler warnings and don't inundate users with their popups.
  ;;   They are rarely more than warnings, so are safe to ignore.
  (setq native-comp-async-report-warnings-errors init-file-debug
        native-comp-warning-on-missing-source init-file-debug)

  (unless (boundp 'native-comp-deferred-compilation-deny-list)
    (defvaralias 'native-comp-deferred-compilation-deny-list
      'native-comp-jit-compilation-deny-list))

  ;; UX: By default, native-comp uses 100% of half your cores. If you're
  ;;   expecting this this should be no issue, but the sudden (and silent) spike
  ;;   of CPU and memory utilization can alarm folks, overheat laptops, or
  ;;   overwhelm less performant systems.
  (define-advice comp-effective-async-max-jobs (:before (&rest _) set-default-cpus)
    "Default to 1/4 of cores in interactive sessions and all of them otherwise."
    (and (null comp-num-cpus)
         (zerop native-comp-async-jobs-number)
         (setq comp-num-cpus
               (max 1 (/ (num-processors) (if noninteractive 1 4))))))

  (define-advice comp-run-async-workers (:around (fn &rest args) dont-litter-tmpdir)
    "Normally, native-comp writes a ton to /tmp. This advice forces it to write
to `doom-cache-dir'/comp/ instead, so that Doom can safely clean it up as part
of 'doom sync' or 'doom gc'."
    (let ((temporary-file-directory (expand-file-name "comp/" cache-dir)))
      (make-directory temporary-file-directory t)
      (apply fn args))))

;; Remove compiled core files if they become stale or Emacs version has changed.
(load e--last-emacs-version-file t (not init-file-debug))
(when (or (not (string= e--last-emacs-version emacs-version))
          (e--became-stale-p))
  (e//remove-byte-compiled-files-in-dir emacs-dir))
;; Update saved Emacs version.
(unless (emacs-version-synced-p)
  (e//update-last-emacs-version))
#+end_src

*** Packages
:PROPERTIES:
:header-args: :noweb-ref core-packages-cfg
:END:

#+BEGIN_SRC elisp :tangle core/core-packages.el :noweb-ref :noweb yes
;; -*- lexical-binding: t; -*-
(require 'core-lib)
(require 'core-load-paths)

<<core-packages-cfg>>

(provide 'core-packages)
;;; core-packages.el ends here.
#+END_SRC

**** Elpaca
***** Bootstrap
#+begin_src elisp
(defvar elpaca-installer-version 0.6)
(defvar elpaca-directory (expand-file-name "elpaca/" cache-dir))
(defvar elpaca-builds-directory (expand-file-name "builds/" elpaca-directory))
(defvar elpaca-repos-directory (expand-file-name "repos/" elpaca-directory))
(defvar elpaca-order '(elpaca :repo "https://github.com/progfolio/elpaca.git"
                              :ref nil
                              :files (:defaults (:exclude "extensions"))
                              :build (:not elpaca--activate-package)))
(let* ((repo  (expand-file-name "elpaca/" elpaca-repos-directory))
       (build (expand-file-name "elpaca/" elpaca-builds-directory))
       (order (cdr elpaca-order))
       (default-directory repo))
  (add-to-list 'load-path (if (file-exists-p build) build repo))
  (unless (file-exists-p repo)
    (make-directory repo t)
    (when (< emacs-major-version 28) (require 'subr-x))
    (condition-case-unless-debug err
        (if-let ((buffer (pop-to-buffer-same-window "*elpaca-bootstrap*"))
                 ((zerop (call-process "git" nil buffer t "clone"
                                       (plist-get order :repo) repo)))
                 ((zerop (call-process "git" nil buffer t "checkout"
                                       (or (plist-get order :ref) "--"))))
                 (emacs (concat invocation-directory invocation-name))
                 ((zerop (call-process emacs nil buffer nil "-Q" "-L" "." "--batch"
                                       "--eval" "(byte-recompile-directory \".\" 0 'force)")))
                 ((require 'elpaca))
                 ((elpaca-generate-autoloads "elpaca" repo)))
            (progn (message "%s" (buffer-string)) (kill-buffer buffer))
          (error "%s" (with-current-buffer buffer (buffer-string))))
      ((error) (warn "%s" err) (delete-directory repo 'recursive))))
  (unless (require 'elpaca-autoloads nil t)
    (require 'elpaca)
    (elpaca-generate-autoloads "elpaca" repo)
    (load "./elpaca-autoloads")))
(add-hook 'after-init-hook #'elpaca-process-queues)
(elpaca `(,@elpaca-order))

#+end_src

***** package.el integration
#+begin_src elisp
(when (>= emacs-major-version 24)
  ;; Install use-package support
  (elpaca elpaca-use-package
    ;; Enable :elpaca use-package keyword.
    (elpaca-use-package-mode)
    ;; Assume :elpaca t unless otherwise specified.
    (setq elpaca-use-package-by-default t)
    (require 'package)
    (csetq package-enable-at-startup nil)
    (package-initialize)
    (pushnew! package-archives
              '("nongnu" . "https://elpa.nongnu.org/nongnu/")
              '("melpa" . "https://melpa.org/packages/"))))
#+end_src

***** Set popup display at side instead of whole screen
#+begin_src elisp
(require 'core-window)
(core-handle-popup (rx "*elpaca-log*"))
;; don't require `use-package' when loading compiled file; saves a millisecond
;; or 2; compiling now saves ~0.1s overall (maybe another 0.1s after general
;; rewrite)

(eval-when-compile
  (require 'use-package)
  ;; don't actually need `eval-when-compile' for rest since currently loading
  ;; entire init file before compiling already
  (csetq use-package-always-defer t))

(defvar +elpaca-hide-log-commands '(eval-buffer eval-region eval-defun +eval-region-or-sexp
                                                eval-last-sexp org-ctrl-c-ctrl-c pp-eval-last-sexp pp-eval-expression)
  "List of commands for which a successfully processed log is auto hidden.")
(defun +elpaca-hide-successful-log ()
  "Hide Elpaca log buffer if queues processed successfully."
  (message "this: %S last: %S" this-command last-command)
  (if-let ((incomplete (cl-find 'incomplete elpaca--queues :key #'elpaca-q<-status))
           ((elpaca-q<-elpacas incomplete)))
      nil
    (when-let ((log (bound-and-true-p elpaca-log-buffer))
               (window (get-buffer-window log t)) ;; log buffer visible
               ((or (member last-command +elpaca-hide-log-commands)
                    (member this-command +elpaca-hide-log-commands))))
      (with-selected-window window (quit-window 'kill window)))))

(defun +elpaca-reload-package (package &optional allp)
  "Reload PACKAGE's features.
If ALLP is non-nil (interactively, with prefix), load all of its
features; otherwise only load ones that were already loaded.

This is useful to reload a package after upgrading it.  Since a
package may provide multiple features, to reload it properly
would require either restarting Emacs or manually unloading and
reloading each loaded feature.  This automates that process.

Note that this unloads all of the package's symbols before
reloading.  Any data stored in those symbols will be lost, so if
the package would normally save that data, e.g. when a mode is
deactivated or when Emacs exits, the user should do so before
using this command."
  (interactive
   (list (let ((elpaca-overriding-prompt "Reload package: "))
           (elpaca--read-queued))
         current-prefix-arg))
  ;; This finds features in the currently installed version of PACKAGE, so if
  ;; it provided other features in an older version, those are not unloaded.
  (when (yes-or-no-p (format "Unload all of %s's symbols and reload its features? " package))
    (let* ((package-name (symbol-name package))
           (package-dir (file-name-directory
                         (locate-file package-name load-path (get-load-suffixes))))
           (package-files (directory-files package-dir 'full (rx ".el" eos)))
           (package-features
            (cl-loop for file in package-files
                     when (with-temp-buffer
                            (insert-file-contents file)
                            (when (re-search-forward (rx bol "(provide" (1+ space)) nil t)
                              (goto-char (match-beginning 0))
                              (cadadr (read (current-buffer)))))
                     collect it)))
      (unless allp
        (setf package-features (seq-intersection package-features features)))
      (dolist (feature package-features)
        (ignore-errors
          ;; Ignore error in case it's not loaded.
          (unload-feature feature 'force)))
      (dolist (feature package-features)
        (require feature))
      (when package-features
        (message "Reloaded: %s" (mapconcat #'symbol-name package-features " "))))))
(add-to-list 'elpaca-ignored-dependencies 'eldoc)

(add-hook 'elpaca-post-queue-hook #'+elpaca-hide-successful-log)

(elpaca-wait)
#+end_src

**** Essential packages

Necessary otherwise version mismatch
#+begin_src elisp
(use-package org)
;; Silence modes from displaying on mode-linep
(use-package diminish :demand t)
#+end_src

***** Lisp helpers
#+begin_src elisp
(use-package async
  :demand t
  :ensure t
  :config
  (async-bytecomp-package-mode 1))
(use-package with-editor)
(use-package hydra
  :demand t
  :ensure t)
(use-package popup)
(use-package dash)
(use-package s)
(use-package f)
#+end_src

***** Security
#+begin_src elisp
(use-package auth-source
  :ensure
  :config
  (setq auth-sources '("~/.authinfo.gpg" "~/.netrc"))
  (auth-source-pass-enable))

(elpaca-wait)

(use-package pinentry
  :after elpaca-after-init-hook
  :ensure t
  :init
  ;; let's get encryption established
  (setenv "GPG_AGENT_INFO" nil)  ;; use emacs pinentry
  (setq auth-source-debug t)

  (require 'epa-file)
  (epa-file-enable)
  (setq epa-pinentry-mode 'loopback)
  (setq epg-pinentry-mode 'loopback)
  (unless 'pinentry-mode
    (pinentry-start))

  (require 'org-crypt)
  (org-crypt-use-before-save-magic)

  ;; Start GPG agent with SSH support
  (shell-command "gpg-connect-agent /bye"))
#+end_src

** init.el
:PROPERTIES:
:header-args: :noweb-ref init-cfg
:END:

#+BEGIN_SRC elisp :tangle init.el :noweb-ref :noweb yes
;; -*- lexical-binding: t; -*-
<<init-license>>
;;; Code:

<<init-cfg>>

;;; init.el ends here.
#+END_SRC

*** license info

#+begin_src elisp :noweb-ref init-license
;; init.el -*- lexical-binding: t -*-

;; Copyright (c) 2021-2023  Junio Santos <info@junio.dev>

;; Author: Junio Santos <hello@junio.dev>
;; URL: https://junio.dev/dotemacs
;; Version: 0.2.0
;; Package-Requires: ((emacs "30.1"))

;; This file is NOT part of GNU Emacs.

;; This file is free software: you can redistribute it and/or modify it
;; under the terms of the GNU General Public License as published by the
;; Free Software Foundation, either version 3 of the License, or (at
;; your option) any later version.
;;
;; This file is distributed in the hoke that it will be useful, but
;; WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
;; General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this file.  If not, seek<https://www.gnu.org/licenses/>.

#+end_src

#+begin_src elisp
;;; Setup path
(require 'subr-x)
(require 'cl-lib)

(defvar emacs-dir (if (string= (expand-file-name "~/.cache/emacs/") user-emacs-directory)
                      (if (file-exists-p "~/.emacs.d/")
                          (expand-file-name "~/.emacs.d/")
                        (expand-file-name "~/.config/emacs/"))
                    ;; else
                    (expand-file-name user-emacs-directory))
  "Emacs root directory.")

(add-to-list 'load-path  (concat emacs-dir "/core/"))
(add-to-list 'load-path (concat emacs-dir "layers/"))
(add-to-list 'load-path (concat emacs-dir "lisp/"))

(require 'core-lib)
(require 'core-load-paths)

;;; Early optimizations
(defun backup-predicate (file)
  "Return whether to backup FILE.
Don't backup remote directories or encrypted files."
  (not (or (file-remote-p file)
           (string-match-p (car epa-file-handler) file))))
#+end_src

*** Frame Settings
#+begin_src elisp
;;(when (interactivep)
(setq frame-resize-pixelwise t
	    frame-inhibit-implied-resize t
	    use-dialog-box nil ; only for mouse events, which I seldom use
	    use-file-dialog nil
	    inhibit-splash-screen t
	    inhibit-startup-screen t
	    inhibit-x-resources t
	    inhibit-startup-echo-area-message user-login-name ; read the docstring
	    inhibit-startup-buffer-menu t)
;;)

(defadvice! __shut-up-autosave-a (fn &rest args)
  "If a file has autosaved data, `after-find-file' will pause for 1 second to
tell you about it. Very annoying. This prevents that."
  :around #'after-find-file
  (letf! ((#'sit-for #'ignore))
    (apply fn args)))
#+end_src

*** User Info
#+begin_src elisp
;; ** User info
(setq-default user-full-name "Junio Santos"
              user-mail-address "git@junio.dev")
#+end_src

*** Adaptive buffer optimization
#+begin_src elisp
;; Avoid buffer lag
(setq process-adaptive-read-buffering nil)
(setq read-process-output-max (* 4 1024 1024)) ; from 800Kb to 4Mb

;; Redirect autosave files to `cache-dir'
(setq backup-directory-alist (list (cons "." (concat cache-dir "backup/")))
      auto-save-list-file-prefix (concat cache-dir "autosave/")
      tramp-auto-save-directory  (concat cache-dir "tramp-autosave/"))

;; Bookmarks
(setq bookmark-default-file (concat cache-dir "bookmarks"))

(defun init--enable-messages-buffer-after-init ()
  "Enable messaging after init and it doesn't populate message
  buffer with loading notification"
  (run-with-timer
   1 nil (lambda () (setq inhibit-message nil))))

(put 'set-goal-column 'disabled nil)

(setq ad-redefinition-action 'accept)

(setq warning-suppress-types '((defvaralias)))

(setq debug-on-error init-file-debug
      jka-compr-verbose init-file-debug)

(setq-default abbrev-mode t)
(setq case-fold-search t) ; Case insensitive searches
(setq font-lock-maximum-decoration t)
(setq global-auto-revert-non-file-buffers t)

(setq set-mark-command-repeat-pop t)
;; stop describe-function from converting many quote characters in docstring
(setq text-quoting-style 'grave)

;; Linux copying is transferred to Emacs kill-ring
;; (setq select-enable-clipboard t)
;; (setq select-enable-primary t)  ; Mouse selection yanks
#+end_src

*** Modes
#+begin_src elisp
;; Basic modes
(electric-pair-mode 1)
(global-subword-mode 1)
(global-auto-revert-mode 1)
(winner-mode 1)
(repeat-mode 1)
(global-goto-address-mode 1)
(delete-selection-mode 1)
(global-visual-line-mode 1)
(minibuffer-depth-indicate-mode 1)
(blink-cursor-mode -1)
(undelete-frame-mode 1) ; Emacs 29
#+end_src

*** Highlight line mode
#+begin_src elisp
(add-hook 'prog-mode-hook #'hl-line-mode)
(add-hook 'text-mode-hook #'hl-line-mode)
(add-hook 'org-mode-hook  #'hl-line-mode)
#+end_src

*** File
#+begin_src elisp
(setq find-file-visit-truename t
      vc-follow-symlinks t)
#+end_src

*** Remove kill when deleting
#+begin_src elisp
(defun NOP-kill-new (orig-func &rest args)
  "Run ORIG-FUNC with ARGS preventing any `kill-new's from running."
  ;; http://endlessparentheses.com/understanding-letf-and-how-it-replaces-flet.html
  (cl-letf (((symbol-function 'kill-new) #'ignore))
    (apply orig-func args)))
(advice-add 'backward-kill-word :around #'NOP-kill-new)

(setq enable-recursive-minibuffers t)

(setq ring-bell-function 'ignore)

(setq-default fill-column 80)
(setq mouse-autoselect-window t
      focus-follows-mouse t)
(csetq visual-line-fringe-indicators '(nil nil))
(csetq split-height-threshold 2
       split-width-threshold 2)

(setq scroll-margin 5
      scroll-conservatively 1)

(setq uniquify-buffer-name-style 'forward)
(setq sentence-end-double-space t)

(setq-default confirm-kill-processes nil) ;emacs 26

;; https://endlessparentheses.com/faster-pop-to-mark-command.html
(defadvice pop-to-mark-command
    (around ensure-new-position activate)
  (let ((p (point)))
    (dotimes (i 10)
      (when (= p (point))
        ad-do-it))))

(setq-default indent-tabs-mode nil
              tab-width 4)
(setq-hook! 'emacs-lisp-mode-hook tab-width 2)

(setq message-log-max 10000)
(setq kill-ring-max 300)
(setq history-length 3000
      history-delete-duplicates t)
(setq frame-title-format '("%b"))
(setq use-short-answers t)
(setq native-compile-prune-cache t) ; Emacs 29
(setq native-comp-async-report-warnings-errors 'silent)
(setq custom-file (expand-file-name "custom.el" cache-dir))

;; increase number of messages
(setq fast-but-imprecise-scrolling t)
(setq adaptive-fill-mode nil)
(setq kill-do-not-save-duplicates t)
(setq show-paren-style 'mixed)

;; Emacs by default will warn you when you use some commands for the first time.
(dolist (c '(narrow-to-region narrow-to-page upcase-region downcase-region
	                            eshell erase-buffer scroll-left dired-find-alternate-file))
  (put c 'disabled nil))

;; And disable these
(dolist (c '(eshell project-eshell overwrite-mode iconify-frame diary))
  (put c 'disabled t))

(setq x-gtk-use-system-tooltips nil
      pos-tip-internal-border-width 1)
(setq x-underline-at-descent-line t)
(setq window-resize-pixelwise t
      frame-resize-pixelwise t)
(setq-default cursor-in-non-selected-windows nil)
(setq highlight-nonselected-windows nil)

(symbol-function 'xah-select-line)
(setq idle-update-delay 1)
(defun my/restore-update-delay ()
  (setq idle-update-delay 0.5))
(add-hook 'after-init-hook 'my/restore-update-delay)

(setq read-file-name-completion-ignore-case t
      read-buffer-completion-ignore-case t
      completion-ignore-case t)

(setq debug-on-error t)
(setq inhibit-message t)
(require 'core-compilation nil t)
(require 'core-packages nil t)

;;; Allow non-floating resizing with mouse.
(csetq window-divider-default-bottom-width 2
       window-divider-default-right-width 2)
(window-divider-mode)

;; Avoid packages store cache on emacs folder.
(setq user-emacs-directory cache-dir)
#+end_src

*** Requiring Modules
#+begin_src elisp
(defconst ju-layers
  '(keymaps
    essentials
    ;; email
    OS
    window
    navigation
    text-editing
    completion
    dir
    langs
    ui
    git
    notes
    readers)
  "list of layers to load.")
(dolist (mod ju-layers)
  (require mod nil t))
#+end_src

*** Ending processes
#+begin_src elisp
  (setq debug-on-error init-file-debug)
  (setq inhibit-message nil)

  (let ((cfile (concat emacs-dir "custom.el")))
    (when (file-exists-p cfile)
      (setq custom-file cfile))
    (add-hook 'elpaca-after-init-hook (lambda () (load custom-file 'noerror))))

  (require 'server)
  (unless (server-running-p)
    (server-start))

  ;;END OF INIT FILE
  ;; prevents `elpaca-after-init-hook` from running more than once.
  (when (require 'elpaca nil t)
    (setq elpaca-after-init-time (or elpaca-after-init-time (current-time)))
    (elpaca-wait))
#+end_src

* Modules
** Essentials
:PROPERTIES:
:header-args: :noweb-ref essentials-cfg
:END:

#+BEGIN_SRC elisp :tangle layers/essentials.el :noweb-ref :noweb yes
  ;; -*- lexical-binding: t; -*-

  <<essentials-cfg>>

  (provide 'essentials)
  ;;; essentials.el ends here.
#+END_SRC

#+begin_src elisp
  (require 'cl-lib)
  (require 'popup-handler)
  (require 'core-packages)

  (defun save-all-history ()
    "Save all commands that somehow store any kind of history, like savehist or recentf."
    (when recentf-mode
      (recentf-save-list))
    (when savehist-mode
      (savehist-save t)))

  ;; save hist files after 10 seconds of idle time
  ;; if not idle, save every 5 minutes
  (run-at-active-interval (* 5 60) 10
    (silently! (save-all-history)))

  (add-hook 'kill-emacs-hook 'save-all-history)
  (display-time-mode)

  (csetq display-time-24hr-format t
         display-time-day-and-date t
         display-time-load-average-threshold nil)

  (use-package auto-save
    :ensure
    :init
    (auto-save-mode)
    ;; auto-save files after 10 seconds of idle time
    ;; if not idle, save every 5 minutes
    (csetq auto-save-interval (* 5 60)
           auto-save-timeout 10))

  (use-package keychain-environment)

  (use-package circe
    :config
    (setq circe-network-options
          '(("Libera Chat"
             :tls t
             :nick "Juniju"
             :channels ("#emacs-circe" "#emacs")
             ))))

  ;; http://yummymelon.com/devnull/customizing-the-emacs-tools-menu.html
  (easy-menu-add-item global-map '(menu-bar tools)
                      ["Magit Status"
                       magit-status
                       :visible (vc-responsible-backend default-directory)
                       :help "Show the status of the current Git repository in a buffer"]
                      "Version Control")

  (use-package savehist
    :ensure nil
    :init
    (setq
     savehist-file (concat cache-dir "savehist-backup")
     save-place-file (concat cache-dir "saveplace")
     auto-save-list-file-prefix (expand-file-name "autosave/" cache-dir)
     auto-save-file-name-transforms `((".*" ,auto-save-list-file-prefix t)))

    (savehist-mode 1)
    (auto-save-mode 1)
    (save-place-mode 1)
    :config
    (csetq history-length 3000 ; from 300
           search-ring-max 150 ; from 16
           mark-ring-max 100
           global-mark-ring-max 100
           regexp-search-ring-max 100
           kmacro-ring-max 100
           history-delete-duplicates t
           savehist-autosave-interval nil
           savehist-save-minibuffer-history t
           savehist-additional-variables
           '(kill-ring                    ; clipboard
             register-alist               ; macros
             mark-ring                    ; marks
             global-mark-ring
             compile-command              ; Compilation
             compile-history
             compilation-directory
             shell-command-history        ; Commands
             extended-command-history
             search-ring                  ; Seaches
             regexp-search-ring))

    (csetq-default
     auto-save-default t
     auto-save-include-big-deletions t)

    (add-hook! 'savehist-save-hook
      (defun savehist-remove-unprintable-registers-h ()
        "Remove unwriteable registers (e.g. containing window configurations).
  Otherwise, `savehist' would discard `register-alist' entirely if we don't omit
  the unwritable tidbits."
        ;; Save new value in the temp buffer savehist is running
        ;; `savehist-save-hook' in. We don't want to actually remove the
        ;; unserializable registers in the current session!
        (setq-local register-alist
                    (cl-remove-if-not #'savehist-printable register-alist)))

      (defun savehist-unpropertize-variables-h ()
        "Remove text properties from `kill-ring' to reduce savehist cache size."
        (setq kill-ring
              (mapcar #'substring-no-properties
                      (cl-remove-if-not #'stringp kill-ring))
              register-alist
              (cl-loop for (reg . item) in register-alist
                       if (stringp item)
                       collect (cons reg (substring-no-properties item))
                       else collect (cons reg item))))))

  (csetq
   ;; save modified buffers without asking
   compilation-ask-about-save nil
   compilation-scroll-output 'first-error)

  ;; http://stackoverflow.com/a/20788581/2744245
  (defun my-colorize-compilation-buffer ()
    (require 'ansi-color)
    (when (eq major-mode 'compilation-mode)
      (ansi-color-apply-on-region compilation-filter-start (point-max))))
  (add-hook 'compilation-filter-hook #'my-colorize-compilation-buffer)
  (noct-handle-popup compilation-mode)

  (require 'zone-words)

  (use-package vimish-fold
    :config
    (vimish-fold-global-mode))

  (use-package 0x0)

  (use-package tmr
    :ensure t
    :custom
    (tmr-sound-file (concat emacs-assets-dir "singing-bowl.wav")))

  (use-package apropos
    :ensure nil
    :init
    ;; TODO can this be put in :config?
    (noct-handle-popup apropos-mode)
    :config
    (setq apropos-do-all t)
    (define-key apropos-mode-map "q" #'quit-window))

  (use-package helpful
    :config
    (map help-map
         "RET" #'helpful-at-point
         "f" #'helpful-callable
         "v" #'helpful-variable
         "k" #'helpful-key
         "o" #'helpful-symbol)

    (noct-handle-popup help-mode)
    (noct-handle-popup (rx "*Help*"))
    (noct-handle-popup helpful-mode))

  (use-package emms
    :config
    (emms-all)
    (setq emms-source-file-default-directory "~/Music"
          emms-info-asynchronously t
          emms-browser-covers #'emms-browser-cache-thumbnail-async
          emms-show-format " %s")

    (if (executable-find "mplayer")
        (setq emms-player-list '(emms-player-mplayer))
      (emms-default-players))
    (global-key "M-7" #'emms-smart-browse))

  (use-package gcmh
    :init
    ;; settings used by doom; default infinite threshold causes Emacs to
    ;; completely freeze after working for a while; maybe this will be better
    (gcmh-mode 1)
    (setq gcmh-idle-delay 10
          gcmh-high-cons-threshold 16777216)
    (add-hook 'focus-out-hook #'gcmh-idle-garbage-collect))

  (use-package recentf
    :ensure nil
    :hook (elpaca-after-init-hook . recentf)
    :init (recentf-mode)
    :custom
    (recentf-save-file (concat cache-dir "recentf"))
    :config
    (global-map "C-x C-r" #'recentf)
    (setq recentf-auto-cleanup nil
          recentf-max-saved-items 200)
    (csetq recentf-exclude '("^/tmp/emacs/.*" ".*/\\.cache/emacs" ".*/\\.rustup" "^/var/folders\\.*" "^/$"
                             "COMMIT_EDITMSG\\'" ".*-autoloads\\.el\\'" "[/\\]\\.elpa/\\'" ".*/bookmarks\\'"
                             "/nix/store/"))

    (setq recentf-auto-cleanup (if (daemonp) 300))
    (add-hook 'kill-emacs-hook #'recentf-save-list)
    (add-hook 'kill-emacs-hook #'recentf-cleanup))

  (use-package clipetty
    :ensure t
    :init
    ;; only need to load if create a terminal frame
    ;; `global-clipetty-mode' will not cause issues if enabled for a server with
    ;; both graphical and terminal frames
    (general-after-tty
      (global-clipetty-mode)))

  (use-package which-key
    :defer 1
    :hook (elpaca-after-init-hook . which-key-mode)
    ;; replace `where-is'; don't need because can show in M-x
    :init
    ;; should be set before loading
    (setq which-key-idle-delay 0.3)
    :config
    (map ju-toggle-map "W" #'which-key-mode)
    (map help-map "w" #'which-key-show-top-level)
    (setq which-key-side-window-location 'bottom
          which-key-sort-order #'which-key-prefix-then-key-order
          which-key-add-column-padding 1
          which-key-max-display-columns nil
          which-key-min-display-lines 6
          which-key-side-window-slot -10
          which-key-sort-uppercase-first nil)
    (which-key-mode))

  (use-package ibuffer
    :ensure nil
    :init (require '+ibuffer)
    :config
    (map ju-buffer-map "i" #'ibuffer)
    (map ibuffer-mode-map
         "<tab>" #'ibuffer-toggle-filter-group
         "q" #'kill-this-buffer)
    (add-hook 'ibuffer-mode-hook
              (lambda ()
                (ibuffer-switch-to-saved-filter-groups "default")
                (ibuffer-update nil t)
                (ibuffer-auto-mode 1)))

    (setq ibuffer-use-header-line t
          ibuffer-expert t
          ibuffer-show-empty-filter-groups nil))

  ;; small QOL
  (defalias #'elisp-mode #'emacs-lisp-mode)

  (use-package password-store)
  (use-package password-store-otp)
  (use-package pass)

  ;; ----------------------------

  (use-package vundo :ensure t)
  (use-package undo-fu :ensure t
    :bind (("C-/" . #'undo-fu-only-undo)
           ("C-S-/" . #'undo-fu-only-redo))
    :custom
    (undo-limit 67108864)          ; 64mb.
    (undo-strong-limit 100663296)  ; 96mb.
    (undo-outer-limit 1006632960)) ; 960mb.

  ;; endup corrupting too frequently
  (use-package undo-tree
    :disabled t
    :init
    (csetq-default undo-tree-history-directory-alist
                   `((".*" . ,(concat cache-dir "undo-tree/"))))
    (global-undo-tree-mode 1))

  (use-package eshell
    :ensure
    :hook
    (eshell-mode-hook . (lambda () (setq outline-regexp eshell-prompt-regexp)))
    :init
    (after! consult
      (require 'em-hist)
      (map eshell-hist-mode-map "C-c C-l" #'consult-history)))

  (use-package eat
    :custom
    (eat-enable-shell-prompt-annotation t)
    :bind
    (:map eat-mode-map
          ("C-t" . 'ju-menu-map)
          ("C-l" . #'eat-reset))
    :hook
    ((eshell-load-hook . eat-eshell-mode)
     (eshell-load-hook . eat-eshell-visual-command-mode)))

  ;; Even coming together with Magit, it is nice to have this separately.
  (use-package transient)
#+end_src

** Completion
:PROPERTIES:
:header-args: :noweb-ref completion-cfg
:END:

#+BEGIN_SRC elisp :tangle layers/completion.el :noweb-ref :noweb yes
  ;; -*- lexical-binding: t; -*-
  <<completion-req>>

  <<completion-cfg>>

  (provide 'completion)
  ;;; completion.el ends here.
#+END_SRC

Require package system
#+begin_src elisp :noweb-ref completion-req
  (require 'core-packages)
#+end_src

#+begin_src elisp
  (use-package cape
    :ensure t
    :init
    (pushnew! completion-at-point-functions
              #'cape-file
              #'cape-abbrev
              #'cape-history))
#+end_src

*** corfu
#+begin_src elisp
  (use-package corfu
    :ensure (corfu :files (:defaults "extensions/*.el"))
    :hook
    ((prog-mode-hook . corfu-mode)
     (shell-mode-hook . corfu-mode)
     (eshell-mode-hook . corfu-mode)
     (eglot-managed . corfu-mode))
    :config
    (defun corfu-enable-in-minibuffer ()
      (when (where-is-internal #'completion-at-point (list (current-local-map)))
        ;; (setq-local corfu-auto nil) ;; Enable/disable auto completion
        (setq-local corfu-echo-delay nil ;; Disable automatic echo and popup
                    corfu-popupinfo-delay nil)
        (corfu-mode 1)))

    (dolist (c '(minibuffer-setup-hook eshell-mode-hook))
      (add-hook c #'corfu-enable-in-minibuffer))

    (csetq corfu-auto t
           corfu-preview-current nil
           corfu-quit-no-match nil
           corfu-auto-delay 0.15
           corfu-indexed-start 1
           corfu-auto-prefix 3)

    (dolist (c (list (cons "SPC" " ")
                     (cons "." ".")
                     (cons "C-(" "\\(")
                     (cons "C-)" "\\)")
                     (cons "C-[" "\\[")
                     (cons "C-]" "\\]")
                     (cons "=" "=")
                     (cons ":" ":")
                     (cons "C-{" "\\[")
                     (cons "C-}" "\\]")
                     (cons "," ",")
                     (cons "-" "-")
                     (cons ":" ":")
                     (cons ")" ")")
                     (cons "}" "}")
                     (cons "]" "]")))
      (define-key corfu-map (kbd (car c)) `(lambda ()
                                             (interactive)
                                             #'(corfu-quit)
                                             (insert ,(cdr c)))))

    (pushnew! savehist-additional-variables 'corfu-history)

    ;; (defmacro generate-corfu-select-index! (index)
    ;;   "return a named function to run `corfu-complete' for index."
    ;;   `(defun! ,(intern (format "ju-corfu-enter-index-%s" index)) ()
    ;;      ,(format "call `corfu-complete' for index %s." index)
    ;;      (interactive)
    ;;      (let ((corfu--index ,index))
    ;;        (corfu-complete))))

    (map corfu-map
         "C-SPC" #'corfu-insert-separator
         "C-h" #'corfu--popup-show
         "C-t" #'corfu-insert
         "C-n" #'corfu-next
         "C-p" #'corfu-previous
         "C-l" #'corfu-complete
         "C-v" #'corfu-scroll-down
         "C-S-v" #'corfu-scroll-up
         "<tab>" #'corfu-complete

         "<return>" #'(lambda () (interactive)
                        (corfu-complete)
                        (call-interactively #'newline))

         "ESC" (defun corfu-quit-minibuffer ()
                 "`escape-quit-minibuffer' but quit corfu if active."
                 (interactive)
                 (when (and (boundp 'corfu--frame)
                            (frame-live-p corfu--frame))
                   (corfu-quit))
                 (keyboard-quit))))
#+end_src

*** utils
**** Orderless
#+begin_src elisp
  (use-package orderless
    :ensure t
    :init
    (csetq completion-styles '(orderless partial-completion basic)
           completion-category-defaults nil
           completion-category-overrides '((file     (styles orderless partial-completion))
                                           ;; enable initialism by default for symbols
                                           (symbol   (styles orderless))
                                           (command  (styles orderless))
                                           (variable (styles orderless)))
           orderless-component-separator #'orderless-escapable-split-on-space ;; allow escaping space with backslash!
           orderless-style-dispatchers (list #'+orderless-consult-dispatch
                                             #'orderless-affix-dispatch))
    :config
    (defvar ju/orderless--separator "[ &]")

    (setq orderless-matching-styles
          '(orderless-literal
            orderless-prefixes
            orderless-initialism
            orderless-regexp))

    :preface
    (defun orderless-fast-dispatch (word index total)
      (and (= index 0) (= total 1) (length< word 1)
           `(orderless-regexp . ,(concat "^" (regexp-quote word)))))

    (defun +orderless-consult-dispatch (word _index _total)
      (cond
       ;; Ensure that $ works with Consult commands, which add disambiguation suffixes
       ((string-suffix-p "$" word)
        `(orderless-regexp . ,(concat (substring word 0 -1) (+orderless--consult-suffix))))
       ;; File extensions
       ((and (or minibuffer-completing-file-name
                 (derived-mode-p 'eshell-mode))
             (string-match-p "\\`\\.." word))
        `(orderless-regexp . ,(concat "\\." (substring word 1) (+orderless--consult-suffix)))))))
#+end_src

**** Prescient
#+begin_src elisp
  (use-package prescient)
#+end_src

**** Sudo
#+begin_src elisp
  (use-package sudo-utils)
#+end_src

**** Spacious padding
#+begin_src elisp
  (use-package spacious-padding
    :init
    (when (require 'spacious-padding nil t)
      (csetq spacious-padding-widths
             '( :internal-border-width 15
                :header-line-width 4
                :tab-width 4
                :right-divider-width 30
                :scroll-bar-width 8))
      (spacious-padding-mode 1)))
#+end_src

*** consult
#+begin_src elisp
  (use-package consult
    :ensure (consult :files (:defaults "consult-*"))
    :defer 0
    :init
    (advice-add #'register-preview :override #'consult-register-window)
    (setq register-preview-delay 0.5
          register-preview-function #'consult-register-format)

    :config
    (map leader-map "SPC" #'switch-to-buffer)
    (map ju-menu-map "C-r" #'projectile-recentf-files)
    (global-map
     "M-s o"   #'consult-org-heading
     "C-s"     #'consult-line
     "M-h"     #'consult-buffer
     "C-x C-r" #'consult-recent-file)

    ;; orderless configuration
    (defun +orderless--consult-suffix ()
      "Regexp which matches the end of string with Consult tofu support."
      (if (and (boundp 'consult--tofu-char) (boundp 'consult--tofu-range))
          (format "[%c-%c]*$"
                  consult--tofu-char
                  (+ consult--tofu-char consult--tofu-range -1))
        "$"))

    ;; Recognizes the following patterns:
    ;; * .ext (file extension)
    ;; * regexp$ (regexp matching at end)



    ;; ----------------------------------------------------------
    ;; Use consult-ripgrep instead of project-find-regexp in project.el
    (keymap-substitute project-prefix-map #'project-find-regexp #'consult-ripgrep)

    (cl-nsubstitute-if
     '(consult-ripgrep "Find regexp")
     (pcase-lambda (`(,cmd _)) (eq cmd #'project-find-regexp))
     project-switch-commands)

    ;; Org Capture
    (defun consult-org-capture-target (scope)
      "Choose a capture target interactively.
  This function returns a value suitable for use as the `target'
  entry of `org-capture-templates'.  SCOPE is as in `org-map-entries'."
      (list 'function
            (lambda ()
              (let ((consult--read-config `((,this-command
                                             :prompt "Capture target: "
                                             :preview-key "M-."))))
                (set-buffer (save-window-excursion
                              (consult-org-heading nil scope)
                              (current-buffer)))))))

    (set 'org-capture-templates
         `(("c" "Consult..." entry ,(consult-org-capture-target 'agenda)
            "* TODO %?\n  %i" :prepend t)))

    (defun consult-org-capture ()
      (interactive)
      (org-capture nil "c"))

    ;; -----------------------
    ;; unique path for recentf
    (defun my-consult--source-recentf-items-uniq ()
      (let ((ht (consult--buffer-file-hash))
            file-name-handler-alist ;; No Tramp slowdown please.
            items)
        (dolist (file (my-recentf-list-uniq) (nreverse items))
          ;; Emacs 29 abbreviates file paths by default, see
          ;; `recentf-filename-handlers'.
          (unless (eq (aref (cdr file) 0) ?/)
            (setcdr file (expand-file-name (cdr file))))
          (unless (gethash (cdr file) ht)
            (push (propertize
                   (car file)
                   'multi-category `(file . ,(cdr file)))
                  items)))))

    (plist-put consult--source-recent-file
               :items #'my-consult--source-recentf-items-uniq)

    (defun my-recentf-list-uniq ()
      (let* ((proposed (mapcar (lambda (f)
                                 (cons (file-name-nondirectory f) f))
                               recentf-list))
             (recentf-uniq proposed)
             conflicts resol file)
        ;; collect conflicts
        (while proposed
          (setq file (pop proposed))
          (if (assoc (car file) conflicts)
              (push (cdr file) (cdr (assoc (car file) conflicts)))
            (if (assoc (car file) proposed)
                (push (list (car file) (cdr file)) conflicts))))
        ;; resolve conflicts
        (dolist (name conflicts)
          (let* ((files (mapcar (lambda (f)
                                  ;; data structure:
                                  ;; (file remaining-path curr-propos)
                                  (list f
                                        (file-name-directory f)
                                        (file-name-nondirectory f)))
                                (cdr name)))
                 (curr-step (mapcar (lambda (f)
                                      (file-name-nondirectory
                                       (directory-file-name (cadr f))))
                                    files)))
            ;; Quick check, if there are no duplicates, we are done.
            (if (eq (length curr-step) (length (seq-uniq curr-step)))
                (setq resol
                      (append resol
                              (mapcar (lambda (f)
                                        (cons (car f)
                                              (file-name-concat
                                               (file-name-nondirectory
                                                (directory-file-name (cadr f)))
                                               (file-name-nondirectory (car f)))))
                                      files)))
              (while files
                (let (files-remain)
                  (dolist (file files)
                    (let ((curr-propos (caddr file))
                          (curr-part (file-name-nondirectory
                                      (directory-file-name (cadr file))))
                          (rest-path (file-name-directory
                                      (directory-file-name (cadr file))))
                          (curr-step
                           (mapcar (lambda (f)
                                     (file-name-nondirectory
                                      (directory-file-name (cadr f))))
                                   files)))
                      (cond ((length= (seq-uniq curr-step) 1)
                             ;; If all elements of curr-step are equal, we skip
                             ;; this path part.
                             (push (list (car file)
                                         rest-path
                                         curr-propos)
                                   files-remain))
                            ((member curr-part (cdr (member curr-part curr-step)))
                             ;; There is more than one curr-part in curr-step
                             ;; for this candidate.
                             (push (list (car file)
                                         rest-path
                                         (file-name-concat curr-part curr-propos))
                                   files-remain))
                            (t
                             ;; There is no repetition of curr-part in curr-step
                             ;; for this candidate.
                             (push (cons (car file)
                                         (file-name-concat curr-part curr-propos))
                                   resol)))))
                  (setq files files-remain))))))
        ;; apply resolved conflicts
        (let (items)
          (dolist (file recentf-uniq (nreverse items))
            (let ((curr-resol (assoc (cdr file) resol)))
              (if curr-resol
                  (push (cons (cdr curr-resol) (cdr file)) items)
                (push file items)))))))
    ;; -----------------------
    (with-eval-after-load 'exwm
      (wm-map "M-y" #'consult-yank-from-kill-ring))

    (defun my/consult-line-forward ()
      "Search for a matching line forward."
      (interactive)
      (consult-line))

    (defun my/consult-line-backward ()
      "Search for a matching line backward."
      (interactive)
      (advice-add 'consult--line-candidates :filter-return 'reverse)
      (vertico-reverse-mode +1)
      (unwind-protect (consult-line)
        (vertico-reverse-mode -1)
        (advice-remove 'consult--line-candidates 'reverse)))

    (consult-customize my/consult-line-backward
                       :prompt "Go to line backward: ")
    (consult-customize my/consult-line-forward
                       :prompt "Go to line forward: ")

    (global-set-key (kbd "C-s") 'my/consult-line-forward)

    ;; ------------------------------------------------------
    (require 'cl-lib)
    (require 'dom)
    (require 'url-util)
    (require 'xml)

    (defun consult--xdg-recent-file-list ()
      "Get a list of recently used files on XDG-compliant systems.

  This function extracts a list of files from the file
  `recently-used.xbel' in the folder `xdg-data-home'.

  For more information on this specification, see
  https://www.freedesktop.org/wiki/Specifications/desktop-bookmark-spec/"
      (let ((data-file (expand-file-name "recently-used.xbel" (xdg-data-home)))
            (xml-parsing-func (if (libxml-available-p)
                                  #'libxml-parse-xml-region
                                #'xml-parse-region)))
        (if (file-readable-p data-file)
            (delq nil
                  (mapcar (lambda (bookmark-node)
                            (when-let ((local-path (string-remove-prefix
                                                    "file://"
                                                    (dom-attr bookmark-node 'href))))
                              (let ((full-file-name (decode-coding-string
                                                     (url-unhex-string local-path)
                                                     'utf-8)))
                                (when (file-exists-p full-file-name)
                                  full-file-name))))
                          (nreverse (dom-by-tag (with-temp-buffer
                                                  (insert-file-contents data-file)
                                                  (funcall xml-parsing-func
                                                           (point-min)
                                                           (point-max)))
                                                'bookmark))))
          (message "consult: List of XDG recent files not found")
          '())))

    (defun consult--recent-system-files ()
      "Return a list of files recently used by the system."
      (cl-case system-type
        (gnu/linux
         (consult--xdg-recent-file-list))
        (t
         (message "consult-recent-file: \"%s\" currently unsupported"
                  system-type)
         '())))

    (defcustom consult-include-system-recent-files t
      "Whether to include files used by other programs in `consult-recent-file'."
      :type 'boolean
      :group 'consult)

    (defun consult--recent-files-mixed-candidates ()
      "Return a list of files recently used by Emacs and the system.

  These files are sorted by modification time, from most recent to least."
      (thread-last
        (consult--recent-system-files)
        (seq-filter #'recentf-include-p)
        (append (mapcar #'substring-no-properties recentf-list))
        delete-dups
        (consult--recent-files-sort)))

    (defun consult--recent-files-sort (file-list)
      "Sort the FILE-LIST by modification time, from most recent to least recent."
      (thread-last
        file-list
        ;; Use modification time, since getting file access time seems to count as
        ;; accessing the file, ruining future uses.
        (mapcar (lambda (f)
                  (cons f (file-attribute-modification-time (file-attributes f)))))
        (seq-sort (pcase-lambda (`(,f1 . ,t1) `(,f2 . ,t2))
                    ;; Want existing, most recent, local files first.
                    (cond ((or (not (file-exists-p f1))
                               (file-remote-p f1))
                           nil)
                          ((or (not (file-exists-p f2))
                               (file-remote-p f2))
                           t)
                          (t (time-less-p t2 t1)))))
        (mapcar #'car)))

    ;;;###autoload
    (defun consult-recent-file ()
      "Find recent using `completing-read'."
      (interactive)
      (find-file
       (consult--read
        (or (mapcar #'abbreviate-file-name
                    recentf-list)
            (user-error "No recent files"))
        :prompt "Find recent file: "
        :sort nil
        :require-match t
        :category 'file
        :state (consult--file-preview)
        :history 'file-name-history)))

    (defun define-minibuffer-key (key &rest defs)
      "Define KEY conditionally in the minibuffer.
  DEFS is a plist associating completion categories to commands."
      (define-key minibuffer-local-map key
                  (list 'menu-item nil defs :filter
                        (lambda (d)
                          (plist-get d (completion-metadata-get
                                        (completion-metadata (minibuffer-contents)
                                                             minibuffer-completion-table
                                                             minibuffer-completion-predicate)
                                        'category))))))

    (define-minibuffer-key "\C-s"
                           'consult-location #'previous-history-element
                           'file #'consult-find-for-minibuffer)

    (defun consult-find-for-minibuffer ()
      "Search file with find, enter the result in the minibuffer."
      (interactive)
      (require 'consult)
      (let* ((enable-recursive-minibuffers t)
             (default-directory (file-name-directory (minibuffer-contents)))
             (file (consult--find
                    (replace-regexp-in-string
                     "\\s-*[:([].*"
                     (format " (via find in %s): " default-directory)
                     (minibuffer-prompt))
                    (consult--find-make-builder)
                    (file-name-nondirectory (minibuffer-contents)))))
        (delete-minibuffer-contents)
        (insert (expand-file-name file default-directory))
        (exit-minibuffer))))

  (use-package consult-gh ; Consult Github
    :after consult
    :ensure (:host github :repo "armindarvish/consult-gh"))

  (use-package consult-dir
    :ensure t
    :bind (("C-x C-d" . consult-dir)
           :map minibuffer-local-completion-map
           ("C-x C-d" . consult-dir)
           ("C-x C-j" . consult-dir-jump-file)))
#+end_src

*** Vertico
#+begin_src elisp

  (use-package vertico
    :ensure t
    :hook ((elpaca-after-init-hook . vertico-mode)
           (minibuffer-setup-hook  . vertico-repeat-save))
    :init
    (vertico-mode 1)
    (vertico-mouse-mode 1)
    (vertico-multiform-mode 1)
    (vertico-indexed-mode 1)
    ;; (vertico-buffer-mode) ;; Not so seamslesly
    (pushnew! savehist-additional-variables 'vertico-repeat-history)
    :config
    (csetq vertico-count 10
           vertico-scroll-margin 8
           vertico-resize t
           vertico-cycle t
           vertico-indexed-start 1) ;; TODO Set this to 0 and change macro impl below

    ;; Vertico Buffer settings
    (when vertico-buffer-mode
      (csetq vertico-buffer-display-action
             '(display-buffer-at-bottom (window-height . 11)))
      (add-hook 'minibuffer-setup-hook (lambda () (setq mode-line-format nil))))

    (csetq vertico-buffer-display-action '(display-buffer-reuse-window)) ; Default

    (csetq vertico-sort-function #'sort-directories-first)

    (csetq vertico-multiform-commands
           '((describe-symbol (vertico-sort-function . vertico-sort-alpha))))
    (csetq vertico-multiform-categories
           '((symbol (vertico-sort-function . vertico-sort-alpha))
             (consult-grep buffer)))

    (defadvice vertico-insert
        (after vertico-insert-add-history activate)
      "Make vertico-insert add to the minibuffer history."
      (unless minibuffer-history-variable
        (add-to-history minibuffer-history-variable (minibuffer-contents))))

    ;; Make sure vertico state is saved
    ;; so commands `vertico-repeat-last' and `vertico-repeat-select' can be useful.
    (add-hook 'minibuffer-setup-hook #'vertico-repeat-save)

    ;; Clear input when inserting a new path with `/' or `~/'
    (add-hook 'rfn-eshadow-update-overlay-hook #'vertico-directory-tidy)

    (dolist (c (list (cons "SPC" " ")
                     (cons "." ".")
                     (cons "C-(" "\\(")
                     (cons "C-)" "\\)")
                     (cons "C-[" "\\[")
                     (cons "C-]" "\\]")
                     (cons "=" "=")
                     (cons ":" ":")
                     (cons "C-1" "(")
                     (cons "C-7" "[")
                     (cons "C-5" "{")
                     (cons "C-3" "}")
                     (cons "C-2" ")")
                     (cons "C-]" "]")))
      (define-key vertico-map (kbd (car c)) `(lambda ()
                                               (interactive)
                                               (insert ,(cdr c)))))

    ;; (defmacro generate-vertico-select-index! (index)
    ;;   "Return a named function to run `vertico-enter' for INDEX."
    ;;   `(defun! ,(intern (format "vertico-enter-index-%s" index)) ()
    ;;      ,(format "Call `vertico-enter' for index %s." index)
    ;;      (interactive)
    ;;      (let ((vertico--index ,index))
    ;;        (vertico-directory-enter))))

    (map vertico-map
         "ESC" nil ;; necessary to avoid prefix errors (TESTING)
         "C-l" #'vertico-repeat-last
         "C-," #'vertico-repeat-select
         "C-p" #'vertico-previous
         "C-n" #'vertico-next
         "C-h" (cmds! (eq 'file (vertico--metadata-get 'category)) #'vertico-directory-up)
         "C-o" #'vertico-first
         "C-w" #'vertico-save

         ;; Scrolling
         "C-v" (lambda () (interactive) (vertico-scroll-down -1))
         "M-v" (lambda () (interactive) (vertico-scroll-down 1))

         "<tab>" #'vertico-insert

         "<return>" #'vertico-directory-enter
         "M-<return>" #'vertico-exit-input ;; insert what is on input and close
         "<backspace>" #'vertico-directory-delete-char
         "C-<backspace>" #'vertico-directory-delete-word
         "<escape>" #'escape ;; Restore ESC behavior
         )

    ;; Sort directories before files
    (defun sort-directories-first (files)
      (setq files (vertico-sort-history-length-alpha files))
      (nconc (seq-filter (lambda (x) (string-suffix-p "/" x)) files)
             (seq-remove (lambda (x) (string-suffix-p "/" x)) files)))

    ;; Prefix the current candidate with  . From
    ;; https://github.com/minad/vertico/wiki#prefix-current-candidate-with-arrow
    (advice-add #'vertico--format-candidate :around
                (lambda (orig cand prefix suffix index _start)
                  (setq cand (funcall orig cand prefix suffix index _start))
                  (concat
                   (if (= vertico--index index)
                       (propertize " " 'face 'vertico-current)
                     "  ")
                   cand)))

    (defvar +vertico-transform-functions nil)

    (cl-defmethod vertico--format-candidate :around
      (cand prefix suffix index start &context ((not +vertico-transform-functions) null))
      (dolist (fun (ensure-list +vertico-transform-functions))
        (setq cand (funcall fun cand)))
      (cl-call-next-method cand prefix suffix index start))

    (defun +vertico-highlight-directory (file)
      "If FILE ends with a slash, highlight it as a directory."
      (if (string-suffix-p "/" file)
          (propertize file 'face 'marginalia-file-priv-dir) ; or face 'dired-directory
        file))

    ;; function to highlight enabled modes similar to counsel-M-x
    (defun +vertico-highlight-enabled-mode (cmd)
      "If MODE is enabled, highlight it as font-lock-constant-face."
      (let ((sym (intern cmd)))
        (if (or (eq sym major-mode)
                (and
                 (memq sym minor-mode-list)
                 (boundp sym)))
            (propertize cmd 'face 'font-lock-constant-face)
          cmd)))

    ;; add-to-list works if 'file isn't already in the alist
    ;; setq can be used but will overwrite all existing values
    (add-to-list 'vertico-multiform-categories
                 '(file
                   ;; this is also defined in the wiki, uncomment if used
                   ;; (vertico-sort-function . sort-directories-first)
                   (+vertico-transform-functions . +vertico-highlight-directory))))

  (use-package vertico-prescient
    :after vertico
    :demand t
    :config
    (setq vertico-prescient-enable-filtering nil)
    (vertico-prescient-mode))

  (use-package vertico-posframe
    :after vertico
    :config
    (vertico-posframe-mode)
    (csetq posframe-mouse-banish-function #'posframe-mouse-banish-simple))
#+end_src

*** Embark
#+begin_src elisp

  (use-package embark
    :ensure t

    :config
    (map global-map
         "C-;" #'embark-dwim
         "C-." #'embark-act)
    (dolist (m  ju//minibuffer-maps)
      (map (symbol-value m)
           "C-SPC" #'embark-select
           "C-." #'embark-act
           "C-;" #'embark-dwim
           "C-h B" #'embark-bindings))
    (setq embark-quit-after-action '((kill-buffer . nil) (t . nil)))
    (defun embark-which-key-indicator ()
      "An embark indicator that displays keymaps using which-key.
  The which-key help message will show the type and value of the
  current target followed by an ellipsis if there are further
  targets."
      (lambda (&optional keymap targets prefix)
        (if (null keymap)
            (which-key--hide-popup-ignore-command)
          (which-key--show-keymap
           (if (eq (plist-get (car targets) :type) 'embark-become)
               "Become"
             (format "Act on %s '%s'%s"
                     (plist-get (car targets) :type)
                     (embark--truncate-target (plist-get (car targets) :target))
                     (if (cdr targets) "" "")))
           (if prefix
               (pcase (lookup-key keymap prefix 'accept-default)
                 ((and (pred keymapp) km) km)
                 (_ (key-binding prefix 'accept-default)))
             keymap)
           nil nil t (lambda (binding)
                       (not (string-suffix-p "-argument" (cdr binding))))))))

    (setq embark-indicators
          '(embark-which-key-indicator
            embark-highlight-indicator
            embark-isearch-highlight-indicator))

    (defun embark-hide-which-key-indicator (fn &rest args)
      "Hide the which-key indicator immediately when using the completing-read prompter."
      (which-key--hide-popup-ignore-command)
      (let ((embark-indicators
             (remq #'embark-which-key-indicator embark-indicators)))
        (apply fn args)))

    (advice-add #'embark-completing-read-prompter
                :around #'embark-hide-which-key-indicator)

    ;; Hide the mode line of the Embark live/completions buffers
    (add-to-list 'display-buffer-alist
                 '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                   nil
                   (window-parameters (mode-line-format . none))))

    (setq prefix-help-command #'embark-prefix-help-command)
    (eval-when-compile
      (defmacro my/embark-ace-action (fn)
        `(defun ,(intern (concat "my/embark-ace-" (symbol-name fn))) ()
           (interactive)
           (with-demoted-errors "%s"
             (require 'ace-window)
             (let ((aw-dispatch-always t))
               (aw-switch-to-window (aw-select nil))
               (call-interactively (symbol-function ',fn)))))))

    (define-key embark-file-map     (kbd "o") (my/embark-ace-action find-file))
    (define-key embark-buffer-map   (kbd "o") (my/embark-ace-action switch-to-buffer))
    (define-key embark-bookmark-map (kbd "o") (my/embark-ace-action bookmark-jump))

    (defun sudo-find-file (file)
      "Open FILE as root."
      (interactive "FOpen file as root: ")
      (when (file-writable-p file)
        (user-error "File is user writeable, aborting sudo"))
      (find-file (if (file-remote-p file)
                     (concat "/" (file-remote-p file 'method) ":"
                             (file-remote-p file 'user) "@" (file-remote-p file 'host)
                             "|sudo:root@"
                             (file-remote-p file 'host) ":" (file-remote-p file 'localname))
                   (concat "/sudo:root@localhost:" file))))
    (define-key embark-file-map (kbd "S") 'sudo-find-file)

    (define-key embark-region-map (kbd "U") '0x0-dwim))

  (use-package embark-consult
    :ensure t ; only need to install it, embark loads it after consult if found
    :hook
    (embark-collect-mode . consult-preview-at-point-mode))
#+end_src

*** Marginalia
#+begin_src elisp
  (use-package marginalia
    :custom
    (marginalia-max-relative-age 0)
    (marginalia-align 'left)
    (marginalia-align-offset 10)
    :init
    (marginalia-mode)
    (csetq marginalia-annotators
           '(marginalia-annotators-heavy marginalia-annotators-light nil)))

  (provide 'completion)
  ;;; completion.el ends here

#+end_src

** Keymaps (replace)
:PROPERTIES:
:header-args: :noweb-ref keymaps-cfg
:END:
# TODO: There really doesn't need to have 2 files to handle keymaps

#+BEGIN_SRC elisp :tangle layers/keymaps.el :noweb-ref :noweb yes
  ;; -*- lexical-binding: t; -*-

  <<keymaps-cfg>>

  (provide 'keymaps)
  ;;; keymaps.el ends here.
#+END_SRC

#+begin_src elisp
  ;;; keymaps.el ---  desc  -*- lexical-binding: t; -*-
  ;;; Commentary:
  ;;; Code:
  (require 'core-packages)
  (require 'core-lib)

  (map global-map "C-s" #'isearch-forward-regexp)

  (define-key input-decode-map (kbd "C-[") [control-bracketleft])
  (define-key input-decode-map (kbd "ESC") [escape])

  ;; Disable arrow keys to force me to use emacs navigation
  (global-map "<left>" nil
              "<right>" nil
              "<up>" nil
              "<down>" nil)

  (global-map "C-," #'execute-extended-command
              "C-x C-s" #'manual-save-buffer
              "M-<right>" #'next-buffer
              "M-<left>"  #'previous-buffer)

  ;; I keep mistakenly using this more than I should
  (global-map "C-x C-l" nil
              "C-x C-n" nil
              "C-c c C-l" #'downcase-region
              "C-c c C-n" #'set-goal-column)

  (global-map "<escape>" #'escape
              "C-h =" #'describe-char)

  ;;-------------------------------------------------
  ;;                Leader map
  ;; ------------------------------------------------

  ;;; Define 'leader-map'
  (create-keymap leader-map)
  (global-map "C-t" leader-map)

  (create-keymap ju-toggle-map)
  (create-keymap ju-search-map)
  (create-keymap ju-emacs-map)
  (create-keymap ju-git-map)
  (create-keymap ju-buffer-map)
  (create-keymap ju-help-map)
  (create-keymap ju-mode-map)
  (create-keymap ju-open-map)
  (create-keymap ju-agenda-map)
  (create-keymap ju-window-map)
  (create-keymap ju-project-map)
  (create-keymap ju-notes-map)
  (create-keymap ju-bookmark-map)
  (create-keymap ju-code-map)
  (create-keymap ju-rectangle-map)
  (create-keymap ju-menu-map)

  (map leader-map
       "a" (cons "Agenda" ju-agenda-map)
       "b" (cons "Buffer" ju-buffer-map)
       "c" (cons "Code" ju-code-map)
       "e" (cons "Emacs" ju-emacs-map)
       "g" (cons "Git" ju-git-map)
       "m" (cons "Mode" ju-mode-map)
       "x" (cons "Menu" ju-menu-map)
       "n" (cons "Notes" ju-notes-map)
       "h" (cons "Help" ju-help-map)
       "o" (cons "Open" ju-open-map)
       "p" (cons "Project" ju-project-map)
       "r" (cons "Bookmark" ju-bookmark-map)
       "s" (cons "Search" ju-search-map)
       "T" (cons "Toggle" ju-toggle-map)
       "w" (cons "Window" ju-window-map)

       "R" (cons "Rectangle" ju-rectangle-map))

  ;; default
  (map leader-map
       "TAB" 'mode-line-other-buffer
       "*" #'delete-window
       "(" #'delete-other-windows
       "-" #'split-window-below
       "v" #'split-window-right
       "k" #'+kill-window)

  (map global-map
       "C-S-c" #'compile
       "C-S-r" #'recompile
       "C-c k" #'+kill-window
       "C-c *" #'delete-window
       "C-c (" #'delete-other-windows
       "C-c -" #'split-window-below
       "C-c v" #'split-window-right
       "C-c TAB" 'mode-line-other-buffer)

  (map ju-buffer-map
       "k" #'+kill-this-buffer
       "i" #'ibuffer
       "b" #'switch-to-buffer)

  (map ju-open-map
       "c" (cons "Emacs Config" (lambda () (interactive) (consult-fd emacs-dir))))

  (map ju-help-map
       "a" #'apropos-command
       "v" #'helpful-variable
       "f" #'helpful-function
       "s" #'helpful-symbol
       "i" #'consult-info)

  ;; bookmark
  (map ju-bookmark-map
       "b" #'consult-bookmark
       "a" #'bookmark-set)

  (map ju-open-map
       "t" #'eat
       "e" (cons "Emacs Config dir" (lambda () (interactive) (consult-fd emacs-dir))))

  (map ju-rectangle-map
       "c" #'delete-whitespace-rectangle
       "d" #'delete-rectangle
       "e" #'rectangle-exchange-point-and-mark
       "i" #'copy-rectangle-to-register
       "k" #'kill-rectangle
       "l" #'rectangle-left-char
       "m" #'rectangle-mark-mode
       "n" #'rectangle-next-line
       "N" #'rectangle-number-lines
       "o" #'open-rectangle
       "p" #'rectangle-previous-line
       "r" #'rectangle-right-char
       "s" #'string-rectangle
       "t" #'string-rectangle
       "x" #'clear-rectangle
       "y" #'yank-rectangle)

  (map ju-menu-map
       "<tab>" #'mode-line-other-buffer
       "b" #'ibuffer
       "c" (cmds! (equal major-mode 'emacs-lisp-mode) #'eval-defun)
       "d" #'dirvish
       "k" #'+kill-window
       "h" #'consult-buffer
       "g" #'consult-ripgrep
       "r" #'consult-recent-file
       "s" #'manual-save-buffer
       "t" #'find-file
       "e" (cmds! (equal major-mode 'emacs-lisp-mode) #'pp-eval-last-sexp))

  (provide 'keymaps)
  ;;; keymaps.el ends here

#+end_src

** Navigation
:PROPERTIES:
:header-args: :noweb-ref navigation-cfg
:END:

#+BEGIN_SRC elisp :tangle layers/navigation.el :noweb-ref :noweb yes
  ;; -*- lexical-binding: t; -*-

  <<navigation-cfg>>

  (provide 'navigation)
  ;;; navigation.el ends here.
#+END_SRC

#+begin_src elisp
  ;;;  -*- lexical-binding: t; -*-
  (require 'core-packages)
  (require 'core-lib)
  (require 'keymaps)
#+end_src

*** Popper
Is a great extension made by Kah and helps manage the /ocean of popups/ that often appers

#+begin_src elisp
  (use-package popper
    :ensure t
    :bind (("C-!" . popper-toggle)
           ("M-!" . popper-cycle)
           ("C-M-!" . popper-toggle-type)
           ("C-8" . popper-kill-latest-popup))
    :init
    ;; Remove any assumptions of which are or aren't popups
    (csetq popper-display-control nil
           popper-group-function nil)
    (csetq popper-reference-buffers
           (list ;; -- Native
            (rx "*Messages*")
            (rx "*Warnings*")
            (rx "Output*" eol)
            ;; -- Packages
            'help-mode 'helpful-mode
            (rx "*eldoc*") 'eldoc-mode
            (rx bol "*elpaca-" (* any))
            ;; -- Shell/tty
            'compilation-mode
            (rx "*Async Shell Command*")
            "^\\*eat.*\\*$"    'eat-mode
            "^\\*term.*\\*$"   'term-mode
            "^\\*vterm.*\\*$"  'vterm-mode
            "^\\*shell.*\\*$"  'shell-mode
            "^\\*eshell.*\\*$" 'eshell-mode))
    (popper-mode 1))
#+end_src

*** Emacs overwriting
#+begin_src elisp
  (map emacs-lisp-mode-map
       "C-c C-c" #'eval-defun
       "C-x C-e" #'pp-eval-last-sexp)
  ;; Misc ------------------------------------------
#+end_src

Grep Emacs settings
#+begin_src elisp
  (defun +consult-ripgrep-emacs ()
    (interactive)
    (consult-ripgrep (list (expand-file-name (concat emacs-dir "layers/"))) "use-package #"))
  (global-set-key (kbd "C-c e") #'+consult-ripgrep-emacs)

  (define-key minibuffer-local-map (kbd "C-n") 'next-line-or-history-element)
  (define-key minibuffer-local-map (kbd "C-p") 'previous-line-or-history-element)

  ;;--------------------------------------------------
#+end_src

Here +meow is called
#+begin_src elisp
  (use-package meow
    :disabled t
    :ensure t
    :preface
    (require '+meow)
    :init
    (meow-setup)
    (meow-global-mode -1))
#+end_src

#+begin_src elisp
  (use-package embrace
    :ensure t
    :bind ("M-," . embrace-commander))

  (use-package avy
    :ensure t
    :commands (avy-goto-word-1 avy-goto-char-2 avy-goto-char-timer)
    :config
    (map global-map
         "M-h"     #'avy-goto-char-2
         "M-s"     (cons "Avy" nil)
         "M-s y"   (cons "Avy: Copy line"   #'avy-copy-line)
         "M-s M-y" (cons "Avy: Copy region" #'avy-copy-region)
         "M-s M-n" (cons "Avy: Line below"  #'avy-goto-line-below)
         "M-s M-p" (cons "Avy: Line above"  #'avy-goto-line-above)
         "M-s M-k" (cons "Avy: Kill Line"   #'avy-kill-whole-line)
         "M-s C-w" (cons "Avy: Kill Region" #'avy-kill-region)
         "M-s M-w" (cons "Avy: Save Region" #'avy-kill-ring-save-region)
         "M-s t"   (cons "Avy: Move Line"   #'avy-move-line)
         "M-s M-t" (cons "Avy: Move Region" #'avy-move-region)
         "M-g l"   (cons "Avy: EOL (end of line)" #'avy-goto-end-of-line))

    (setq avy-single-candidate-jump nil)
    (setq avy-timeout-seconds 0.20)
    (setq avy-keys '(?a ?o ?e ?u ?i
                        ?h ?n ?r
                        ?k ?x ?b)))

  (use-package ace-window
    :ensure t
    :bind (("M-o" . ace-window)
           ("M-]" . delete-window)
           ("C-]" . ace-window))
    :config
    (csetq aw-dispatch-always nil
           aw-scope 'global
           aw-background nil
           aw-keys '(?h ?t ?n ?u ?e ?o ?a ?i))
    (csetq aw-dispatch-alist
           '((?d aw-delete-window "Delete Window")
             (?s aw-swap-window "Swap Windows")
             (?m aw-move-window "Move Window")
             (?c aw-copy-window "Copy Window")
             (?j aw-switch-buffer-in-window "Select Buffer")
             (?\t aw-flip-window)
             (?b aw-switch-buffer-other-window "Switch Buffer Other Window")
             (?c aw-split-window-fair "Split Fair Window")
             (?v aw-split-window-vert "Split Vert Window")
             (?- aw-split-window-horz "Split Horz Window")
             (?D delete-other-windows "Delete Other Windows")
             (?? aw-show-dispatch-help))))

  (use-package repeat
    :ensure nil
    :init
    (repeat-mode 1)
    ;; Spawn or hide a which-key popup
    (defvar +org-link-repeat-map
      (let ((map (make-sparse-keymap)))
        (define-key map (kbd "n") 'org-next-link)
        (define-key map (kbd "p") 'org-previous-link)
        map))
    (dolist (cmd '(org-next-link org-previous-link))
      (put cmd 'repeat-map '+org-link-repeat-map))

    (defvar switch-buffer-repeat-map
      (let ((map (make-sparse-keymap)))
        (define-key map (kbd "<right>") 'next-buffer)
        (define-key map (kbd "<left>") 'previous-buffer)
        (define-key map (kbd "k") '+kill-this-buffer)
        (define-key map (kbd "n") 'next-buffer)
        (define-key map (kbd "p") 'previous-buffer)
        map))
    (dolist (cmd '(next-buffer previous-buffer))
      (put cmd 'repeat-map 'switch-buffer-repeat-map))

    (defvar kill-buffer-repeat-map
      (let ((map (make-sparse-keymap)))
        (define-key map (kbd "k") '+kill-window)
        (define-key map (kbd "n") 'next-buffer)
        (define-key map (kbd "p") 'previous-buffer)
        map))
    (dolist (cmd '(+kill-window))
      (put cmd 'repeat-map 'kill-buffer-repeat-map))

    (defvar windmove-repeat-map
      (let ((map (make-sparse-keymap)))
        (define-key map (kbd "<left>") 'windmove-left)
        (define-key map (kbd "S-<left>") 'windmove-swap-states-left)
        (define-key map (kbd "<right>") 'windmove-right)
        (define-key map (kbd "S-<right>") 'windmove-swap-states-right)
        (define-key map (kbd "<up>") 'windmove-up)
        (define-key map (kbd "S-<up>") 'windmove-swap-states-up)
        (define-key map (kbd "<down>") 'windmove-down)
        (define-key map (kbd "S-<down>") 'windmove-swap-states-down)
        map))
    (map-keymap
     (lambda (_key cmd)
       (when (symbolp cmd)
         (put cmd 'repeat-map 'windmove-repeat-map)))
     windmove-repeat-map))

  (use-package repeat-help
    :ensure t
    :init (repeat-help-mode))

  (use-package smartparens
    :ensure t
    :hook (emacs-lisp-mode . smartparens-mode)
    :config
    (defvar structural-edit-map
      (let ((map (make-sparse-keymap)))
        (pcase-dolist (`(,k . ,f)
                       '(("u" . backward-up-list)
                         ("f" . forward-sexp)
                         ("b" . backward-sexp)
                         ("d" . down-list)
                         ("k" . kill-sexp)
                         ("n" . sp-next-sexp)
                         ("p" . sp-previous-sexp)
                         ("K" . sp-kill-hybrid-sexp)
                         ("]" . sp-forward-slurp-sexp)
                         ("[" . sp-backward-slurp-sexp)
                         ("}" . sp-forward-barf-sexp)
                         ("{" . sp-backward-barf-sexp)
                         ("C" . sp-convolute-sexp)
                         ("J" . sp-join-sexp)
                         ("S" . sp-split-sexp)
                         ("R" . sp-raise-sexp)
                         ("\\" . indent-region)
                         ("/" . undo)
                         ("t" . transpose-sexps)
                         ("x" . eval-defun)))
          (define-key map (kbd k) f))
        map))

    (map-keymap
     (lambda (_ cmd)
       (put cmd 'repeat-map 'structural-edit-map))
     structural-edit-map)
    (map  leader-map "C-u" structural-edit-map))

  ;; (add-hook 'emacs-lisp-mode (lambda () (smartparens-mode))

  (use-package drag-stuff
    :init
    (drag-stuff-global-mode)
    :config
    (with-eval-after-load 'meow
      (meow-normal-define-key
       '("M-p" . drag-stuff-up)
       '("M-n" . drag-stuff-down)))
    (global-key "M-<up>"   #'drag-stuff-up
                "M-<down>" #'drag-stuff-down))

  (use-package multiple-cursors)

  (use-package mwim
    :ensure t
    :init
    (global-map
     "C-a" #'beginning-of-line
     "C-e" #'mwim-end-of-code-or-line))

  (use-package hl-todo
    :config
    (global-hl-todo-mode))

  (defmacro wrap-region-with-symbol! (sym &optional ending)
    `(defun ,(intern (format "wrap-with-%s"
                             (if (stringp sym)
                                 sym
                               (cl-gensym)))) ()
       ,(format "Insert %s on beginning and end between mark" sym)
       (interactive)
       (let ((BEGIN (region-beginning))
             (END (region-end)))
         (setq mark-active nil)
         (save-excursion
           (goto-char BEGIN)
           (insert ,sym)
           (goto-char (1+ END))
           (if (stringp ,ending)
               (insert ,ending)
             (insert ,sym)))
         (forward-char)) ; Cursor stay on top of symbol
       ))

  (map emacs-lisp-mode-map
       "'" (lambda () (interactive) (insert-char ?'))
       "#" (lambda () (interactive) (insert "#'")))

  ;;; Xah Lee Keymaps:
  (defvar xah-brackets '("" "()" "[]" "{}" "<>"
  		                   "" "" "" ""
  		                   "" "" "" "" ""
  		                   "" "" "" ""
  		                   "" "" "" ""
  		                   "" "" "" "" ""
  		                   "" "" "" "" "" ""
  		                   "" "" "" "" ""
  		                   "" "" "" "" ""
  		                   "" "" "" "" ""
  		                   "" "" "" "" "" ""
  		                   "" "" "" "" ""
  		                   "" "" "")
    "A list of strings, each element is a string of 2 chars, the left
  bracket and a matching right bracket.
    Used by `xah-select-text-in-quote' and others.
    Version 2023-07-31")

  (defconst xah-left-brackets
    (mapcar (lambda (x) (substring x 0 1)) xah-brackets)
    "List of left bracket chars. Each element is a string.")

  (defconst xah-right-brackets
    (mapcar (lambda (x) (substring x 1 2)) xah-brackets)
    "List of right bracket chars. Each element is a string.")

  (defun xah-select-text-in-quote ()
    "Select text between the nearest left and right delimiters.
    Delimiters here includes the following chars: \" ` and anything in `xah-brackets'.
    This command ignores nesting. For example, if text is
    		(a(b)c)
    the selected char is c, not a(b)c.

    URL `http://xahlee.info/emacs/emacs/modernization_mark-word.html'
    Version: 2020-11-24 2023-07-16 2023-07-23"
    (interactive)
    (let ((xskipChars (concat "^\"`" (mapconcat #'identity xah-brackets ""))))
      (skip-chars-backward xskipChars)
      (push-mark (point) t t)
      (skip-chars-forward xskipChars)))

  ;; Select Current Line
  (defun xah-select-line ()
    "Select current line. If region is active, extend selection downward by line.
    If `visual-line-mode' is on, consider line as visual line.

    URL `http://xahlee.info/emacs/emacs/modernization_mark-word.html'
    Version: 2017-11-01 2021-03-19 2023-07-16"
    (interactive)
    (if (region-active-p)
        (if visual-line-mode
    	      (let ((xp1 (point)))
    	        (end-of-visual-line 1)
    	        (when (eq xp1 (point))
    	          (end-of-visual-line 2)))
    	    (progn
    	      (forward-line 1)
    	      (end-of-line)))
      (if visual-line-mode
    	    (progn (beginning-of-visual-line)
    	           (push-mark (point) t t)
    	           (end-of-visual-line))
        (progn
    	    (push-mark (line-beginning-position) t t)
    	    (end-of-line)))))

  ;; Select Current Block
  (defun xah-select-block ()
    "Select the current/next block plus 1 blankline.
    If region is active, extend selection downward by block.

    URL `http://xahlee.info/emacs/emacs/modernization_mark-word.html'
    Version: 2019-12-26 2021-04-04 2021-08-13"
    (interactive)
    (if (region-active-p)
        (re-search-forward "\n[ \t]*\n[ \t]*\n*" nil 1)
      (progn
        (skip-chars-forward " \n\t")
        (when (re-search-backward "\n[ \t]*\n" nil 1)
    	    (goto-char (match-end 0)))
        (push-mark (point) t t)
        (re-search-forward "\n[ \t]*\n" nil 1))))

  ;; Extend Selection
  (defun xah-extend-selection ()
    "Select the current word, bracket/quote expression, or expand selection.
    Subsequent calls expands the selection.

    when there is no selection,
     If cursor is on any type of bracket (including parenthesis, quotation mark), select whole bracketed thing including bracket
     else, select current word.

    when there is a selection, the selection extension behavior is still experimental. But when cursor is on a any type of bracket (parenthesis, quote), it extends selection to outer bracket.

    URL `http://xahlee.info/emacs/emacs/modernization_mark-word.html'
    Version: 2020-02-04 2023-07-22 2023-07-23"
    (interactive)
    (if (region-active-p)
        (progn
          (let ((xrb (region-beginning)) (xre (region-end)))
            (goto-char xrb)
            (cond
             ((looking-at "\\s(")
              (if (eq (nth 0 (syntax-ppss)) 0)
                  (progn
                    ;; (message "left bracket, depth 0.")
                    (end-of-line) ; select current line
                    (push-mark (line-beginning-position) t t))
                (progn
                  ;; (message "left bracket, depth not 0")
                  (up-list -1 t t)
                  (mark-sexp))))
             ((eq xrb (line-beginning-position))
              (progn
                (goto-char xrb)
                (let ((xfirstLineEndPos (line-end-position)))
                  (cond
                   ((eq xre xfirstLineEndPos)
                    (progn
                      ;; (message "exactly 1 line. extend to next whole line." )
                      (forward-line 1)
                      (end-of-line)))
                   ((< xre xfirstLineEndPos)
                    (progn
                      ;; (message "less than 1 line. complete the line." )
                      (end-of-line)))
                   ((> xre xfirstLineEndPos)
                    (progn
                      ;; (message "beginning of line, but end is greater than 1st end of line" )
                      (goto-char xre)
                      (if (eq (point) (line-end-position))
                          (progn
                            ;; (message "exactly multiple lines" )
                            (forward-line 1)
                            (end-of-line))
                        (progn
                          ;; (message "multiple lines but end is not eol. make it so" )
                          (goto-char xre)
                          (end-of-line)))))
                   (t (error "%s: logic error 42946" real-this-command))))))
             ((and (> (point) (line-beginning-position)) (<= (point) (line-end-position)))
              (progn
                ;; (message "less than 1 line" )
                (end-of-line) ; select current line
                (push-mark (line-beginning-position) t t)))
             (t
              ;; (message "last resort" )
              nil))))
      (progn
        (cond
         ((looking-at "\\s(")
          ;; (message "left bracket")
          (mark-sexp)) ; left bracket
         ((looking-at "\\s)")
          ;; (message "right bracket")
          (backward-up-list) (mark-sexp))
         ((looking-at "\\s\"")
          ;; (message "string quote")
          (mark-sexp)) ; string quote
         ;; ((and (eq (point) (line-beginning-position)) (not (looking-at "\n")))
         ;;  (message "beginning of line and not empty")
         ;;  (end-of-line)
         ;;  (push-mark (line-beginning-position) t t))
         (
          ;; (prog2 (backward-char) (looking-at "[-_a-zA-Z0-9]") (forward-char))
          (looking-back "[-_a-zA-Z0-9]" (max (- (point) 1) (point-min)))
          ;; (message "left is word or symbol")
          (skip-chars-backward "-_a-zA-Z0-9")
          ;; (re-search-backward "^\\(\\sw\\|\\s_\\)" nil t)
          (push-mark)
          (skip-chars-forward "-_a-zA-Z0-9")
          (setq mark-active t)
          ;; (exchange-point-and-mark)
          )
         ((and (looking-at "[:blank:]")
               (prog2 (backward-char) (looking-at "[:blank:]") (forward-char)))
          ;; (message "left and right both space" )
          (skip-chars-backward "[:blank:]") (push-mark (point) t t)
          (skip-chars-forward "[:blank:]"))
         ((and (looking-at "\n")
               (eq (char-before) 10))
          ;; (message "left and right both newline")
          (skip-chars-forward "\n")
          (push-mark (point)  t t)
          (re-search-forward "\n[ \t]*\n")) ; between blank lines, select next block
         (t
          ;; (message "just mark sexp" )
          (mark-sexp)
          (exchange-point-and-mark))
         ;;
         ))))

  (defun xah-goto-matching-bracket ()
    "Move cursor to the matching bracket.
    If cursor is not on a bracket, call `backward-up-list'.
    The list of brackets to jump to is defined by `xah-left-brackets' and `xah-right-brackets'.

    URL `http://xahlee.info/emacs/emacs/emacs_navigating_keys_for_brackets.html'
    Version: 2016-11-22 2023-07-22"
    (interactive)
    (if (nth 3 (syntax-ppss))
    		(backward-up-list 1 'ESCAPE-STRINGS 'NO-SYNTAX-CROSSING)
    	(cond
    	 ((eq (char-after) ?\") (forward-sexp))
    	 ((eq (char-before) ?\") (backward-sexp))
    	 ((looking-at (regexp-opt xah-left-brackets))
    		(forward-sexp))
    	 ((prog2 (backward-char) (looking-at (regexp-opt xah-right-brackets)) (forward-char))
    		(backward-sexp))

  	   (t (backward-up-list 1 'ESCAPE-STRINGS 'NO-SYNTAX-CROSSING)))))

  (general-def
    "M-6" #'xah-select-block
    "M-7" #'xah-select-line
    "M-8" #'xah-extend-selection
    "M-9" #'xah-select-text-in-quote
    "C-<tab>" #'xah-goto-matching-bracket)

  (defun prot-common-shell-command-with-exit-code-and-output (command &rest args)
    "Run COMMAND with ARGS.
  Return the exit code and output in a list."
    (with-temp-buffer
      (list (apply 'call-process command nil (current-buffer) nil args)
            (buffer-string))))

  (defvar prot-eww--punctuation-regexp "[][{}!@#$%^&*()_=+'\"?,.\|;:~`]*"
    "Regular expression of punctionation that should be removed.")

  (defun prot-eww--slug-no-punct (str)
    "Convert STR to a file name slug."
    (replace-regexp-in-string prot-eww--punctuation-regexp "" str))

  (defun prot-eww--slug-hyphenate (str)
    "Replace spaces with hyphens in STR.
  Also replace multiple hyphens with a single one and remove any
  trailing hyphen."
    (replace-regexp-in-string
     "-$" ""
     (replace-regexp-in-string
      "-\\{2,\\}" "-"
      (replace-regexp-in-string "--+\\|\s+" "-" str))))

  (defun prot-eww--sluggify (str)
    "Make STR an appropriate file name slug."
    (downcase (prot-eww--slug-hyphenate (prot-eww--slug-no-punct str))))

  (setq eww-download-directory (expand-file-name "~/Documents/pages/"))

  ;;;###autoload
  (defun prot-eww-download-html (name)
    "Download web page and call the file with NAME."
    (interactive
     (list
      (prot-eww--sluggify
       (read-string "Set downloaded file name: " (plist-get eww-data :title)))))
    (let* ((path (thread-last eww-download-directory
                              (expand-file-name
                               (concat (format-time-string "%Y%m%d_%H%M%S") "--" name ".html"))))
           (out (prot-common-shell-command-with-exit-code-and-output
                 "wget" "-q" (format "%s" (plist-get eww-data :url))
                 "-O" (format "%s" (shell-quote-argument path)))))
      (if (= (car out) 0)
          (message "Downloaded page at %s" path)
        (message "Error downloading page: %s" (cdr out)))))

  (progn
    (require 'eww)
    (define-key eww-mode-map (kbd "D") #'prot-eww-download-html))

  (defun scroll-up-half ()
    (interactive)
    (scroll-up-command
     (floor
      (- (window-height)
         next-screen-context-lines)
      2)))

  (defun scroll-down-half ()
    (interactive)
    (scroll-down-command
     (floor
      (- (window-height)
         next-screen-context-lines)
      2)))

  ;;;; Substitute this with eval-defun
  ;;
  ;; (defun +eval-region-or-sexp ()
  ;;   "When a evaluate the region if is active, otherwise eval sexp on point."
  ;;   (interactive)
  ;;   (if (not (region-active-p))
  ;;       (call-interactively 'eval-last-sexp)
  ;;     (call-interactively 'eval-region)
  ;;     (when (region-active-p)
  ;;       (deactivate-mark))
  ;;     (message "Region evaluated.")))

  ;; https://karthinks.com/software/more-less-emacs/
  (defvar-local hide-cursor--original nil)

  (define-minor-mode hide-cursor-mode
    "Hide or show the cursor.
  When the cursor is hidden `scroll-lock-mode' is enabled, so that
  the buffer works like a pager."
    :global nil
    :lighter "H"
    (if hide-cursor-mode
        (progn
          (scroll-lock-mode 1)
          (setq-local hide-cursor--original
                      cursor-type)
          (setq-local cursor-type nil))
      (scroll-lock-mode -1)
      (setq-local cursor-type (or hide-cursor--original
                                  t))))

  (map ju-toggle-map "h" 'hide-cursor-mode)
  (global-map "<f7>" 'hide-cursor-mode)


  (provide 'navigation)
  ;;; navigation.el ends here

#+end_src
** Programming Languages
:PROPERTIES:
:header-args: :noweb-ref langs-cfg
:END:

#+BEGIN_SRC elisp :tangle layers/langs.el :noweb-ref :noweb yes
  ;; -*- lexical-binding: t; -*-
  (require 'core-packages)

  <<langs-cfg>>

  (provide 'langs)
  ;;; langs.el ends here
#+END_SRC

#+begin_src elisp
  ;;; Tools:
  (add-hook 'prog-mode-hook #'column-number-mode)
  (defconst use-eglot t)

  (use-package tempel
    :init
    ;; Setup completion at point
    (setq tempel-template-sources 'tempel-path-templates)
    (setq tempel-path (concat emacs-dir "templates"))

    (defun tempel-setup-capf ()
      ;; Add the Tempel Capf to `completion-at-point-functions'.
      ;; `tempel-expand' only triggers on exact matches. Alternatively use
      ;; `tempel-complete' if you want to see all matches, but then you
      ;; should also configure `tempel-trigger-prefix', such that Tempel
      ;; does not trigger too often when you don't expect it. NOTE: We add
      ;; `tempel-expand' *before* the main programming mode Capf, such
      ;; that it will be tried first.
      (setq-local completion-at-point-functions
                  (cons #'tempel-expand
                        completion-at-point-functions)))

    (add-hook 'conf-mode-hook 'tempel-setup-capf)
    (add-hook 'prog-mode-hook 'tempel-setup-capf)
    (add-hook 'text-mode-hook 'tempel-setup-capf)
    (defun +tempel-complete-or-end ()
      (interactive)
      (if tempel--active (call-interactively #'tempel-done) (call-interactively #'tempel-complete)))

    :bind
    (:map global-map
          ("M-t" . #'+tempel-complete-or-end)
          :map org-mode-map
          ("M-t" . #'+tempel-complete-or-end))

    :preface
    (defun l (item-list)
      "Receive a list and make the user select one item."
      (if-let ((selected-item (completing-read "Select item: " item-list)))
          selected-item
        nil))

    ;; TODO: Move this to lib
    (defun empty-line ()
      "Returns true in case current line is empty"
      (when (save-excursion (re-search-backward "^\\S-*$" (line-beginning-position) 'noerror))
        t)))

  (use-package yasnippet
    :disabled t
    :init (yas-global-mode 1)
    :custom
    (yas-snippet-dirs `(,(concat emacs-dir "snippets/")))
    :config
    (add-hook 'rust-mode-hook
              (lambda ()
                (setq yas-buffer-local-condition
                      yas-not-string-or-comment-condition))))

  (use-package ellama
    :init
    (setopt ellama-language "English")
    (require 'llm-ollama)
    (setopt ellama-provider
            (make-llm-ollama
             :chat-model "zephyr"
             :embedding-model "zephyr")))

  (use-package eldoc
    :after elpaca-after-init-hook
    :ensure t
    :config
    (setq eldoc-idle-delay 0.5
          eldoc-current-idle-delay 0.5)
    (add-to-list 'display-buffer-alist
                 '("\\*eldoc\\*"
                   (display-buffer-in-side-window)
                   (side . right)
                   (slot . 0)
                   (window-width . 80)
                   (window-parameters
                    (no-delete-other-windows . t)))))

  (use-package eldoc-box
    :after eldoc)

  (use-package devdocs
    :ensure t
    :init
    (add-hook 'rust-mode-hook (lambda () (setq-local devdocs-current-docs '("rust")))))

  (use-package indent-bars
    :ensure (:host github :repo "jdtsmith/indent-bars")
    :custom
    (indent-bars-color '(highlight :face-bg t :blend 0.2))
    (indent-bars-pattern ".")
    (indent-bars-highlight-current-depth nil)
    (indent-bars-width-frac 0.1)
    (indent-bars-pad-frac 0.1)
    (indent-bars-zigzag nil)
    (indent-bars-color-by-depth nil)
    (indent-bars-display-on-blank-lines nil)
    (indent-bars-treesit-support t)
    (indent-bars-no-descend-string t)
    (indent-bars-treesit-ignore-blank-lines-types '("module"))
    :hook ((rustic-mode rust-mode toml-mode yaml-mode lua-mode) . indent-bars-mode))

  (use-package flycheck
    :init (global-flycheck-mode)
    :config
    ;; Avoid "No file or directory" errors when requiring local packages
    (eval-and-compile
      (setq flycheck-emacs-lisp-load-path load-path))

    (setq flycheck-display-errors-delay 0.01
          flycheck-idle-change-delay 0.01
          flycheck-idle-buffer-switch-delay 0.01))

  (use-package flycheck-eglot
    :if use-eglot
    :after eglot
    :init (global-flycheck-eglot-mode))

  (use-package rainbow-mode
    :init (rainbow-mode)
    :config
    ;; remove highlighting color names (useful only in CSS)
    (setq rainbow-x-colors nil))

  (use-package project
    :no-require t
    :ensure nil
    :init
    (csetq project-vc-extra-root-markers '(".env" "Cargo.toml" "justfile"))
    (defvar project-root-markers '("Cargo.toml" "justfile")
      "Files or directories that indicate the root of a project.")

    (defun aorst/project-find-root (path)
      "Tail-recursive search in PATH for root markers."
      (require 'transient)
      (let* ((this-dir (file-name-as-directory (file-truename path)))
             (parent-dir (expand-file-name (concat this-dir "../")))
             (system-root-dir (expand-file-name "/")))
        (cond
         ((aorst/project-root-p this-dir) (cons 'transient this-dir))
         ((equal system-root-dir this-dir) nil)
         (t (aorst/project-find-root parent-dir)))))

    (defun aorst/project-root-p (path)
      "Check if current PATH has any of project root markers."
      (let ((results (mapcar (lambda (marker)
                               (file-exists-p (concat path marker)))
                             project-root-markers)))
        (eval `(or ,@ results))))
    (add-hook 'project-find-functions 'aorst/project-find-root))

  (use-package projectile
    :ensure t
    :defer 0
    :commands (projectile-project-root
               projectile-project-name
               projectile-locate-dominating-file
               projectile-relevant-known-projects
               projectile-project-p)
    :config
    (csetq projectile-auto-discover nil
           projectile-sort-order 'recently
           projectile-enable-caching (not noninteractive)
           projectile-project-search-path '("~/dev/"))

    (map global-map
         "C-t C-r" #'projectile-recentf
         "C-t C-f" #'projectile-find-file
         "C-t C-g" #'+projectile-ripgrep)

    (defun +projectile-ripgrep ()
      (interactive)
      (consult-ripgrep projectile-project-root))

    (pushnew! projectile-globally-ignored-directories
              "^\\.cache$" "tmp" "^target$")

    (projectile-mode +1))

  (use-package tree-sitter-langs
    :after tree-sitter)

  (use-package tree-sitter
    :config
    (require 'tree-sitter-langs)
    (global-tree-sitter-mode)
    (add-hook 'tree-sitter-after-on-hook #'tree-sitter-hl-mode))

  (global-hi-lock-mode 1)
  (setq hi-lock-file-patterns-policy #'(lambda (dummy) t))

  (use-package eglot
    :if use-eglot
    :bind (:map eglot-mode-map
                ("C-h ." . eldoc))
    :hook ((eglot-managed-mode . my/eglot-eldoc-settings))
    :config
    (defun my/eglot-eldoc-settings ()
      (csetq eldoc-documentation-strategy
             'eldoc-documentation-compose-eagerly))

    (after! cape
      (defun my/eglot-capf ()
        (setq-local completion-at-point-functions
                    (list (cape-capf-super
                           'cape-file))))

      (add-hook 'eglot-managed-mode-hook #'my/eglot-capf)
      (advice-add 'eglot-completion-at-point :around #'cape-wrap-buster)
      (advice-add 'eglot-completion-at-point :around #'cape-wrap-noninterruptible))

    (setq completion-category-overrides '((eglot (styles orderless))))
    (setq eglot-ignored-server-capabilites '(:inlayHintProvider)))

  (use-package lsp-mode
    :unless use-eglot
    :commands lsp
    :custom
    (lsp-completion-provider :none) ;; we use Corfu!
    :init
    (defun my/lsp-mode-setup-completion ()
      (setf (alist-get 'styles (alist-get 'lsp-capf completion-category-defaults))
            '(orderless))) ;; Configure orderless
    :hook
    (lsp-completion-mode . my/lsp-mode-setup-completion)
    (;; replace XXX-mode with concrete major-mode(e. g. python-mode)
     (rustic-mode . lsp)
     (rust-mode . lsp)
     ;; if you want which-key integration
     (lsp-mode . lsp-enable-which-key-integration)))
  (use-package jsonrpc)
  (use-package jinja2-mode)


  (use-package lsp-ui
    :hook
    (lsp-ui-mode . lsp-mode))
  (use-package web-mode)
  (use-package haskell-mode)
  (use-package dape
    :ensure (:host github :repo "svaante/dape"))

  (use-package restclient
    :ensure t)

  ;;
  ;;; Languages:
  (use-package sml-mode)
  (use-package yuck-mode)
  (use-package nushell-mode)
  (use-package nushell-ts-mode)
  (use-package typescript-mode)
  (use-package markdown-mode)
  (use-package lua-mode
    :mode "\\.lua\\'")

  (use-package nix-mode)
  ;; rust
  (use-package rustic
    :mode "\\.rs\\'"
    :init
    (when use-eglot
      (remove-hook 'rustic-mode-hook 'flycheck-mode)
      (csetq rustic-setup-eglot t
             rustic-lsp-client 'eglot))

    (csetq rustic-compile-directory-method 'rustic-buffer-workspace
           rustic-enable-detached-file-support t
           rustic-format-on-save nil
           rustic-cargo-check-exec-command "clippy"
           rustic-analyzer-command '("rustup" "run" "stable" "rust-analyzer")
           rustic-cargo-check-arguments "-- -W clippy::pedantic -W clippy::nursery -W clippy::unwrap_used"))
#+end_src
**
** UI
:PROPERTIES:
:header-args: :noweb-ref ui-cfg
:END:

#+BEGIN_SRC elisp :tangle layers/ui.el :noweb-ref :noweb yes
  ;; -*- lexical-binding: t; -*-

  <<ui-cfg>>

  (provide 'ui)
#+END_SRC

#+begin_src elisp
  (require 'core-lib)
  (require 'core-packages)

  (use-package beacon
    :ensure t
    :hook (beacon-mode . prog-mode-hook))

  (use-package doom-modeline
    :init (doom-modeline-mode 1))
#+end_src

**** Font Settings
#+begin_src elisp
(defvar default-font "Iosevka Comfy")
(defvar fixed-pitch-font "Fantasque Sans Mono")
(defvar variable-pitch-font "Iosevka Aile")

(set-face-attribute 'default nil :family default-font)
(set-face-attribute 'fixed-pitch nil :family fixed-pitch-font)
(set-face-attribute 'variable-pitch nil :family variable-pitch-font)
(set-face-attribute 'mode-line nil :family variable-pitch-font)

(set-face-attribute 'default nil :height 160)

;; Unicode
(csetq-default use-default-font-for-symbols nil)

(set-fontset-font t 'unicode (face-attribute 'default :family))
(dolist (font '("Symbola"
                   "Symbols Nerd Font"
                   "Twemoji"
                   "Noto Color Emoji"
                   "Noto Sans Mro"
                   "Noto Sans SignWriting"
                   "FreeSerif"))
  (when (member font (font-family-list))
    (set-fontset-font t 'unicode font nil 'append)))
(set-fontset-font t 'unicode (font-spec :family "Noto Sans") nil 'append)


(use-package emojify
  :hook (elpaca-after-init-hook . global-emojify-mode)
  :bind
  (:map ju-menu-map
        ("." . #'emoji-search))
  :custom
  (emojify-display-style 'unicode)
  (emojify-emoji-styles '(unicode)))

(use-package fontaine
  :config
  (csetq fontaine-presets `((small
                             :default-family ,fixed-pitch-font
                             :default-height 80
                             :variable-pitch-family ,variable-pitch-font)
                            (regular)
                            (medium
                             :default-weight semilight
                             :default-height 115
                             :bold-weight extrabold)
                            (large
                             :inherit medium
                             :default-height 150)
                            (presentation
                             :inherit medium
                             :default-weight light
                             :default-height 180)
                            (t
                             :default-family ,default-font
                             :default-weight regular
                             :default-height 160
                             :fixed-pitch-family ,fixed-pitch-font
                             :fixed-pitch-weight nil ; use default weight
                             :fixed-pitch-height 1.0
                             :variable-pitch-family ,variable-pitch-font
                             :variable-pitch-weight nil
                             :variable-pitch-height 1.0
                             :bold-family nil
                             :bold-weight bold
                             :italic-family nil
                             :italic-slant italic
                             :line-spacing nil)
                            (default))))

(csetq winner-boring-buffers-regexp " \*Minibuf-[0-9]+")
;; Internal border


;; Line spacing, can be 0 for code and 1 or 2 for text
(setq-default line-spacing 0)
(add-hook 'text-mode-hook (lambda () (setq line-spacing 1)))

(tool-bar-mode -1)
(scroll-bar-mode -1)

#+end_src

Add frame borders and window dividers
#+begin_src elisp
(modify-all-frames-parameters
 '((right-divider-width . 40)
   (vertical-scroll-bars . nil)
   (internal-border-width . 24)))
(dolist (face '(window-divider
                window-divider-first-pixel
                window-divider-last-pixel))
  (face-spec-reset-face face)
  (set-face-foreground face (face-attribute 'default :background)))
(set-face-background 'fringe (face-attribute 'default :background))
#+end_src

#+begin_src elisp
;; No Tooltips
(tooltip-mode 0)
#+end_src

Org related
#+begin_src elisp
(csetq
 ;; Edit settings
 org-auto-align-tags nil
 org-tags-column 0
 org-catch-invisible-edits 'show-and-error
 org-special-ctrl-a/e t
 org-insert-heading-respect-content t

 ;; Org styling, hide markup etc.
 org-hide-emphasis-markers t
 org-pretty-entities t
 org-ellipsis ""

 ;; Agenda styling
 org-agenda-tags-column 0
 org-agenda-block-separator ?
 org-agenda-time-grid
 '((daily today require-timed)
   (800 1000 1200 1400 1600 1800 2000)
   "  " "")
 org-agenda-current-time-string
 "< now ")
#+end_src

#+begin_src elisp
;; Underline line at descent position, not baseline position
(setq x-underline-at-descent-line t)

;; Fringes only in programming mode
(add-hook 'prog-mode-hook (defun! ju//fringe-mode-set ()
                            (fringe-mode '(13 . 0))))

;; Vertical window divider
(setq window-divider-default-right-width 3)
(setq window-divider-default-places 'right-only)
(window-divider-mode)

(with-eval-after-load 'org
  (setq org-display-inline-images t)
  (setq org-redisplay-inline-images t)
  (setq org-startup-with-inline-images "inlineimages")
  (setq org-hide-emphasis-markers t)
  (setq org-link-elisp-confirm-function nil))

;; Nice glyphs for truncated and wrapped lines
(defface face-faded nil
  "Oo." :group 'koi)
(defface fallback '((t :family "Fantasque Mono Sans"
                       :inherit 'face-faded)) "Fallback.")
(set-display-table-slot standard-display-table 'truncation
                        (make-glyph-code ? 'fallback))
(set-display-table-slot standard-display-table 'wrap
                        (make-glyph-code ? 'fallback))
(set-display-table-slot standard-display-table 'selective-display
                        (string-to-vector " "))

;; No ugly button for checkboxes
(csetq widget-image-enable nil)

;; No sound
(setq visible-bell t)
(setq ring-bell-function 'ignore)

(csetq indicate-empty-lines t)

(+handle-popup (rx "Output*" eol))
(+handle-popup (rx "*Warnings*") t)
(+handle-popup (rx "*eldoc*") t)
(+handle-popup (rx bol "*elpaca-" (* any)) t)

(csetq scroll-conservatively 1000)
(csetq mouse-wheel-scroll-amount '(1 ((shift) . 1)))

(add-hook! '(text-mode-hook prog-mode-hook)
  (lambda () (size-indication-mode)))

;; No limit on font lock
(csetq font-lock-maximum-size nil)

;; Stop prompting about your true desire of killing innocent processes
(setq kill-buffer-query-functions
      (remq 'process-kill-buffer-query-function
            kill-buffer-query-functions))

;; No confirmation for visiting non-existent files
(setq confirm-nonexistent-file-or-buffer nil)

;; Mouse active in terminal
(unless (display-graphic-p)
  (xterm-mouse-mode 1)
  (global-set-key (kbd "<mouse-4>") 'scroll-down-line)
  (global-set-key (kbd "<mouse-5>") 'scroll-up-line))

;; Minimum window height
(setq window-min-height 1)

;; Size of temporary buffers
(temp-buffer-resize-mode)
(setq temp-buffer-max-height 8)

;; Buffer encoding
(prefer-coding-system       'utf-8)
(set-default-coding-systems 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(set-language-environment   'utf-8)

;; Unique buffer names
(require 'uniquify)
(csetq uniquify-buffer-name-style 'reverse
       uniquify-separator "  "
       uniquify-after-kill-buffer-p t
       uniquify-ignore-buffers-re "^\\*")

;; Kill term buffer when exiting
(defadvice term-sentinel (around my-advice-term-sentinel (proc msg))
  (if (memq (process-status proc) '(signal exit))
      (let ((buffer (process-buffer proc)))
        ad-do-it
        (kill-buffer buffer))
    ad-do-it))
(ad-activate 'term-sentinel)

;; ** Font
;; (set-fontset-font t #xFE0F spec-1)                ;; Variation Selector 16
;; (set-fontset-font t '(#x1F1E6 . #x1F1FF) spec-2)  ;; Regional Indicator Syms
;; (set-fontset-font t '(#x1F3FB . #x1F3FF) spec-3)  ;; Emoji Modifiers
;; (set-fontset-font t '(#x1F700 . #x1F77F) spec-4)  ;; Alchemical Symbols
(use-package mixed-pitch
  :hook
  ;; Acts on all modes for text editing (including org, markdown, etc.).
  (text-mode . mixed-pitch-mode))

  (set-language-environment "UTF-8")
  (set-default-coding-systems 'utf-8-unix)
  (setq emojify-display-style 'unicode)
  (setq emojify-emoji-styles '(unicode))
  (when (member "Fantasque Sans Mono" (font-family-list))
    (set-frame-font "Fantasque Sans Mono 14")
    (add-to-list 'default-frame-alist
                 '(font . "Fantasque Mono Sans 14"))
    (face-remap-add-relative 'fixed-pitch :family "Fantasque Mono Sans"))



  (use-package ligature
    :ensure t
    :init
    (ligature-set-ligatures 't '("www"))
    ;; Enable ligatures in programming modes
    (ligature-set-ligatures 'prog-mode '("www" "**" "***" "**/" "*>" "*/" "\\\\"
                                         "\\\\\\" "{-" "::" ":::" ":=" "!!" "!="
                                         "!==" "-}" "----" "-->" "->" "->>" "-<"
                                         "-<<" "-~" "#{" "#[" "##" "###" "####"
                                         "#(" "#?" "#_" "#_(" ".-" ".=" ".."
                                         "..<" "..." "?=" "??" ";;" ";;;" "/*"
                                         "/**" "/=" "/==" "/>" "//" "///" "&&"
                                         "||" "||=" "|=" "|>" "^=" "$>" "++" "+++"
                                         "+>" "=:=" "==" "===" "==>" "=>" "=>>"
                                         "<=" "<<" "=/=" ">-" ">=" ">=>" ">>"
                                         ">>-" ">>=" ">>>" "<*" "<*>" "<|" "<|>"
                                         "<$" "<$>" "<!--" "<-" "<--" "<->" "<+"
                                         "<+>" "<=" "<==" "<=>" "<=<" "<>" "<<"
                                         "<<-" "<<=" "<<<" "<~" "<~~" "</" "</>"
                                         "~@" "~-" "~>" "~~" "~~>" "%%"))
    (global-ligature-mode 1))

  (use-package highlight-defined
    :ensure t
    :init
    (highlight-defined-mode 1))

  (use-package mini-echo
    :disabled
    :custom
    (mini-echo-right-padding 10)
    :init
    (setq hl-line-sticky-flag nil)
    (setq global-hl-line-sticky-flag nil)
    (setq mini-echo-separator "  ")
    ;; set default segments of long/short style
    (setq-default mini-echo-default-segments
                  '(:long  ("time" "major-mode" "eglot" "vcs" "buffer-position"
                            "flymake" "process" "narrow" "macro" "profiler"
                            "meow" "buffer-name" "buffer-size" "selection-info")
                           :short ("buffer-name-short" "meow" "buffer-position" "process"
                                   "profiler" "selection-info" "narrow" "macro")))
    (mini-echo-mode))

  (use-package highlight-escape-sequences
    :after 'modus-themes
    :init
    (general-after-gui
      (hes-mode)))

  (use-package maple-minibuffer
    :ensure (:host github :repo "honmaple/emacs-maple-minibuffer")
    :config
    (setq maple-minibuffer:position-type 'frame-bottom-center
          maple-minibuffer:border-color
          (or (ignore-errors (ewal-get-color 'foreground) "gray50"))
          maple-minibuffer:height nil
          maple-minibuffer:width 0.7
          maple-minibuffer:cache t))

  (setq echo-keystrokes 1)

  ;; Icons
  (use-package all-the-icons)
  (use-package all-the-icons-completion
    :init
    (all-the-icons-completion-mode)
    :config
    (add-hook 'marginalia-mode-hook #'all-the-icons-completion-marginalia-setup))

  (use-package kind-icon
    :ensure t
    :after corfu
    ;;  :custom
    ;;  (kind-icon-default-face 'corfu-default) ; to compute blended backgrounds correctly
    :config
    (csetq completion-in-region-function
           (kind-icon-enhance-completion
            (lambda (&rest args)
              (apply (if vertico-mode
                         #'consult-completion-in-region
                       #'completion--in-region)
                     args))))
    (setq kind-icon-extra-space t)
    (add-to-list 'corfu-margin-formatters #'kind-icon-margin-formatter))

  (use-package modus-themes
    :preface
    (defun set-theme ()
      "Set theme and config."
      (interactive)
      (load-theme 'modus-vivendi-tinted :no-confirm)
      (font-lock-add-keywords 'emacs-lisp-mode
                              (list
                               (cons (rx (or (and bow "'") "#'" " . ")) 'font-lock-constant-face)
                               '("(\\|)" . 'font-lock-punctuation-face)
                               (cons (rx (and bow "?" (not "?"))) 'font-lock-punctuation-face)
                               '("[0-9]" . 'font-lock-number-face)))
      (set-face-attribute
       'font-lock-constant-face nil
       :foreground "#f9b37f")

      (custom-set-faces
       ;; custom-set-faces was added by Custom.
       ;; If you edit it by hand, you could mess it up, so be careful.
       ;; Your init file should contain only one such instance.
       ;; If there is more than one, they won't work right.
       '(custom-variable-tag ((t (:inherit bold :foreground "medium sea green"))))
       '(dired-directory ((t (:foreground "SkyBlue1"))))
       '(diredp-file-name ((t (:foreground "light blue"))))
       '(flymake-end-of-line-diagnostics-face ((t (:inherit modus-themes-slant
                                                            :box (:line-width (1 . 1) :color "#61647a")
                                                            :height 0.85))))
       '(font-lock-punctuation-face ((t (:foreground "#8c7ec7"))))
       '(fringe ((t (:background "#101d20"))))
       '(whitespace-trailing ((t (:foreground "#9d1f1f"))))
       '(show-paren-match-expression ((t (:box nil :background "#2c273a"))))
       '(flymake-error-echo-at-eol ((t (:foreground "#ff5f59"))))
       '(modus-themes-lang-warning ((t (:underline "#f9b37f"))) t)
       '(cursor ((t (:background "#4b93ab"))))
       '(flymake-note-echo-at-eol ((t (:foreground "#6ae4b9" :box nil))))
       '(font-lock-warning-face ((t (:inherit modus-themes-bold :foreground "violet"))))
       '(whitespace-line ((t (:foreground "gainsboro" :underline (:color "RoyalBlue4" :style wave :position nil)))))
       '(whitespace-space-after-tab ((t (:inherit whitespace-space)))))

      (with-eval-after-load 'hl-line-mode
        (set-face-attribute
         'hl-line nil
         :background "#2c273a"
         :box '(:line-width (-1 . -1):color "#1d1f24" :style 'flat)))

      (set-face-attribute 'fringe nil
                          :background "#101d20")

      (set-face-background 'default "#1d1f24")

      (set-face-attribute 'font-lock-comment-face nil
                          :slant 'italic)

      (set-face-attribute 'font-lock-keyword-face nil
                          :weight 'bold)

      (with-eval-after-load 'eglot
        (set-face-attribute 'eglot-highlight-symbol-face nil
                            :underline t
                            :bold nil))

      (set-face-attribute 'font-lock-number-face nil
                          :foreground "#f9b37f")

      (with-eval-after-load 'hl-line-mode
        (set-face-attribute
         'highlight-numbers-number nil
         :foreground "#f9b37f"))

      (set-face-attribute
       'font-lock-regexp-grouping-backslash nil
       :foreground "#f9b37f" :bold nil)

      (set-face-attribute
       'font-lock-regexp-grouping-construct nil
       :foreground "#86b2d3" :bold t)

      (set-face-attribute
       'font-lock-regexp-face nil
       :foreground "#e0def4" :bold t)

      (set-face-attribute ;; comment for test
       'font-lock-comment-face nil
       :foreground "#9c7ec7")

      (with-eval-after-load 'org-mode
        (set-face-attribute ;; comment for test
         'org-hide nil
         :foreground "#8c7ec7"))

      (set-face-attribute
       'font-lock-string-face nil
       :foreground "#a3bbae")

      (set-face-attribute
       'font-lock-builtin-face nil
       :foreground "#bab4fe")

      (set-face-attribute
       'font-lock-keyword-face nil
       :foreground "#bab4fe")

      (set-face-attribute
       'font-lock-function-name-face nil
       :foreground "#97DED7")

      (set-face-attribute
       'show-paren-match nil
       :background "unspecified" :bold t
       :box '(:line-width (-1 . -1) :color "#f8a4b6" :style 'flat)))
    :init
    (require 'modus-themes)
    (ju-after-gui
      (set-theme)))

  (ju-after-gui
    (setq mode-line-format nil)

    (kill-local-variable 'mode-line-format)

    (force-mode-line-update)


    (setq-default mode-line-format
                  '("%e"
                    my-modeline-buffer-name
                    "%&"
                    "  "
                    my-modeline-major-mode))

    (defface my-modeline-background
      '((t :background "#3355bb" :foreground "white" :inherit bold))
      "Face with a red background for use on the mode line.")

    (defun my-modeline--buffer-name ()
      "Return `buffer-name' with spaces around it."
      (format " %s " (buffer-name)))

    (defvar-local my-modeline-buffer-name
        '(:eval
          (when (mode-line-window-selected-p)
            (propertize (my-modeline--buffer-name) 'face 'my-modeline-background)))
      "Mode line construct to display the buffer name.")

    (put 'my-modeline-buffer-name 'risky-local-variable t)

    (defun my-modeline--major-mode-name ()
      "Return capitalized `major-mode' as a string."
      (capitalize (symbol-name major-mode)))

    (defvar-local my-modeline-major-mode
        '(:eval
          (list
           "\tL%l,C%c\t"
           (propertize "" 'face 'shadow)
           " "
           (propertize (my-modeline--major-mode-name) 'face 'bold)))
      "Mode line construct to display the major mode.")

    (put 'my-modeline-major-mode 'risky-local-variable t)

    ;; Emacs 29, check the definition right below
    (mode-line-window-selected-p)

    (defun mode-line-window-selected-p ()
      "Return non-nil if we're updating the mode line for the selected window.
This function is meant to be called in `:eval' mode line
constructs to allow altering the look of the mode line depending
on whether the mode line belongs to the currently selected window
or not."
      (let ((window (selected-window)))
        (or (eq window (old-selected-window))
	          (and (minibuffer-window-active-p (minibuffer-window))
	               (with-selected-window (minibuffer-window)
	                 (eq window (minibuffer-selected-window))))))))

  (provide 'ui)
;;; ui.el ends here
#+end_src
** Org/notes
:PROPERTIES:
:header-args: :noweb-ref notes-cfg
:END:

#+BEGIN_SRC elisp :tangle layers/notes.el :noweb-ref :noweb yes
;; -*- lexical-binding: t; -*-
(require '+org)

<<notes-cfg>>

(provide 'notes)
#+END_SRC

Early on, as always, we will enable lexical-binding for a better
environment binding and this way be less prone to bugs and allowing
an easier life for the compiler since for being static less time
is required for optimization

***** Config
#+begin_src elisp
(use-package org
  :ensure
  :config
  (map ju-notes-map
       "c" #'org-capture)
  (map org-mode-map
       "C-t" 'ju-menu-map
       "C-," #'execute-extended-command
       "C-c d" #'org-todo
       "C-c h" #'consult-org-heading
       "C-c TAB" #'mode-line-other-buffer
       "C-c C-t" #'+org-toggle-todo-and-fold
       "C-c C-d" #'org-babel-demarcate-block
       "TAB" #'org-cycle
       "<up>" #'org-move-subtree-up
       "<down>" #'org-move-subtree-down
       "<left>" #'org-demote-subtree
       "<right>" #'org-promote-subtree)

  ;; Org Src editing goes on the side (better to edit)
  (noct-handle-popup (rx "*Org Src " (+ any) "*" eol) nil right)

  (csetq org-capture-bookmark nil)
  (setq require-final-newline t)
  (setq org-directory user-notes-dir
        org-default-notes-file (expand "00000000T000011--notes.org" user-notes-dir))

  ;; run after a resettable delay of 0.3 seconds.
  ;;  (debounce! 'org-agenda-do-context-action 0.3)
  (setq org-tab-first-hook #'+org-cycle-only-current-subtree-h)

  (setq org-use-speed-commands t)

  ;; Allow org snippets with `<`
  (add-to-list 'org-modules 'org-tempo)
  (setq org-structure-template-alist
        '(("c" . "comment")
          ("e" . "src elisp")
          ("E" . "example")
          ("h" . "export html")
          ("l" . "export latex")
          ("q" . "quote")
          ("s" . "src")
          ("r" . "src rust")
          ("x" . "export")))

  ;; display images
  (setq org-display-remote-inline-images t
        org-startup-with-inline-images t
        org-cycle-inline-images-display t)

  ;; better default
  (setq org-catch-invisible-edits nil
        org-hide-emphasis-markers t
        org-enforce-todo-dependencies t)

  ;; indent
  (setq org-startup-folded t
        org-startup-indented t
        org-list-indent-offset 2
        org-pretty-entities t
        org-cycle-separator-lines 2)

  ;; Agenda
  (setq org-agenda-custom-commands
        '(("c" "Calendar" agenda ""
           ((org-agenda-span 7)
            (org-agenda-start-on-weekday 0)
            (org-agenda-time-grid nil)
            (org-agenda-repeating-timestamp-show-all t)
            (org-agenda-entry-types '(:timestamp :sexp))))

          ("d" "Upcoming deadlines" agenda ""
           ((org-agenda-time-grid nil)
            (org-deadline-warning-days 365)
            (org-agenda-entry-types '(:deadline))))

          ("o" "Today" tags-todo "@dev"
           ((org-agenda-overriding-header "Development")
            (org-agenda-skip-function #'my-org-agenda-skip-all-siblings-but-first)))

          ("g" . "GTD contexts")
          ("gd" "Dev" tags-todo "development")
          ("gs" "Computer" tags-todo "studies")
          ("gp" "Projects" tags-todo "projects")))

  (setq org-agenda-files (list (concat org-directory "00000000T000001--agenda.org")))

  ;; Save Org buffers after refiling!
  ;; Removed: fill `recentf' list
  ;; (advice-add 'org-refile :after 'org-save-all-org-buffers)
  (csetq org-tag-alist
         '((:startgroup)
           (:endgroup)
           ("@errand" . ?E)
           ("@home" . ?H)
           ("@work" . ?W)
           ("agenda" . ?a)
           ("event" . ?e)
           ("planning" . ?p)
           ("blog" . ?b)
           ("idea" . ?i)))

  (csetq org-todo-keywords
         '((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d)")
           (sequence "EVENT(e)" "|" "TRYST(y)")
           (sequence "WAITING(w@/!)" "HOLD(h@/!)" "|" "CANCELLED(c@/!)"))
         org-todo-keyword-faces
         '(("TODO" :foreground "#f9667a" :weight bold)
           ("NEXT" :foreground "#86b2d3" :weight bold)
           ("DONE" :foreground "#4b93ab" :weight bold)
           ("EVENT" :foreground "#bab4fe" :weight bold)
           ("WAITING" :foreground "#f9b37f" :weight bold)
           ("HOLD" :foreground "#bab4fe" :weight bold)
           ("CANCELLED" :foreground "#a3bbae" :weight bold)
           ("MEETING" :foreground "#a3bbae" :weight bold)
           ("PHONE" :foreground "#a3bbae" :weight bold)))

  (add-hook 'kill-emacs-hook #'ju/org--clock-out)

  ;; Babel
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((C . t)
     (sql . t)
     (python . t)
     (emacs-lisp . t)))
  (setq-default org-confirm-babel-evaluate nil
                 org-src-fontify-natively t
                 org-src-tab-acts-natively t)

#+end_src

****** Preface (loaded before anything else)
#+begin_src elisp
:preface
(defun ju.org-toggle-todo-and-fold ()
  (interactive)
  (save-excursion
    (org-back-to-heading t) ;; Make sure command works even if point is
    ;; below target heading
    (cond ((looking-at "\*+ TODO")
           (org-todo "DONE")
           (outline-hide-subtree))
          ((looking-at "\*+ DONE")
           (org-todo "TODO")
           (outline-hide-subtree))
          (t (message "Can only toggle between TODO and DONE.")))))
(size-indication-mode)

(defun ju/org--clock-out()
  (org-clock-out nil t))

(defun my-org-agenda-skip-all-siblings-but-first ()
  "Skip all but the first non-done entry."
  (let (should-skip-entry)
    (unless (org-current-is-todo)
      (setq should-skip-entry t))
    (save-excursion
      (while (and (not should-skip-entry) (org-goto-sibling t))
        (when (org-current-is-todo)
          (setq should-skip-entry t))))
    (when should-skip-entry
      (or (outline-next-heading)
          (goto-char (point-max))))))

(defun org-current-is-todo ()
  (string= "TODO" (org-get-todo-state)))
#+end_src

End of org block
#+begin_src elisp
) ;; End of `use-package org`
#+end_src

***** Utils
#+begin_src elisp
;; support to append notes on PDF, EPub and others
(use-package org-noter
  :ensure t
  :custom
  ;; Save the last location you visited and pick it up when you start another session
  (org-noter-auto-save-last-location t))

(use-package org-special-block-extras
  :hook (org-mode . org-special-block-extras-mode)
  :config
  (org-defblock noweb-template
                (:tangle "no" :backend emacs-lisp :noweb yes :noweb-ref nil)
                "Generate a template for config"))

(use-package org-modern
  :ensure t
  :hook (org-mode . global-org-modern-mode)
  :config
  (set-face-attribute 'org-modern-symbol nil :family fixed-pitch-font))

(use-package org-pdftools
  :after org-noter)

;; A kind of spaced repetition tool
(use-package org-drill)

;; Show marks on cursor
(use-package org-appear
  :ensure t
  :init
  (add-hook 'org-mode-hook 'org-appear-mode))

(defvar emacs-assets-dir (expand "assets/" emacs-dir))

(use-package org-pomodoro
  :ensure t
  :after org
  :commands (org-pomodoro-start org-pomodoro)
  :bind (("<f12>" . work-pomodoro))
  ;; :hook ((org-pomodoro-started . ju/load-window-close-agenda)
  ;;        (org-pomodoro-finished . ju/save-window-show-agenda))
  :config
  ;; Send visual notification when a timer ends
  (csetq alert-user-configuration '(((((:category . "org-pomodoro")) libnotify nil))))
  (csetq org-pomodoro-format "%s"
         org-pomodoro-start-sound (expand "bells.wav" emacs-assets-dir)
         org-pomodoro-finished-sound (expand "bells.wav" emacs-assets-dir)
         org-pomodoro-overtime-sound (expand "bells.wav" emacs-assets-dir)
         org-pomodoro-long-break-sound (expand "singing-bowl.wav" emacs-assets-dir)
         org-pomodoro-short-break-sound (expand "singing-bowl.wav" emacs-assets-dir)
         org-pomodoro-clock-break t
         org-pomodoro-manual-break t)

  (defun meditate-pomodoro ()
    (interactive)
    (csetq org-pomodoro-length 10)
    (org-pomodoro-start))

  (defun work-pomodoro ()
    (interactive)
    (csetq org-pomodoro-length 25
           org-pomodoro-short-break-length 5
           org-pomodoro-long-break-length 20)
    (if (not (org-pomodoro-active-p))
        (progn
          (org-pomodoro-start)
          (message "Pomodoro started/unpaused"))
      (progn
        (org-pomodoro t)
        (message "Pomodoro Paused"))))

  (defun ju/save-window-show-agenda ()
    (interactive)
    (window-configuration-to-register "`")
    (delete-other-windows)
    (org-save-all-org-buffers)
    (org-agenda nil "w"))

  (defun ju/load-window-close-agenda ()
    (interactive)
    (org-save-all-org-buffers)
    (jump-to-register "`")))

(use-package org-journal
  :config
  (map ju-notes-map
   "t" '(org-journal-open-current-journal-file :wk "Today's journal")
   "o" '(org-journal-new-entry :wk "Open journal"))

  (setq
   org-journal-date-prefix "#+title: "
   org-journal-file-format "%Y-%m-%d.org"
   org-journal-dir (expand "private/journal" user-notes-dir)
   org-journal-date-format "%A, %d %B %Y"))

(use-package org-superstar
  :hook (org-mode .  org-superstar-mode)
  :disabled t
  :custom
  (set-face-attribute 'org-superstar-item nil :height 0.8)
  (set-face-attribute 'org-superstar-header-bullet nil :height 0.8)
  (set-face-attribute 'org-superstar-leading nil :height 0.8)
  (org-ellipsis " ")
  (org-superstar-special-todo-items t)
  (org-superstar-headline-bullets-list '("" "" "" "" "" "")) ;;  usechar `'  if first symbol don't work
  (org-superstar-item-bullet-alist '((?* . ?) (?+ . ?) (?- . ?)))) ; changes +/- symbols in item lists

(use-package toc-org
  :config
  ;; enable in markdown, too
  (add-hook 'markdown-mode-hook 'toc-org-mode))
#+end_src

#+begin_src elisp
(defun tangle-reload ()
  (interactive)
  (let ((org-file (concat emacs-dir "cfg.org"))
        (init-file (concat emacs-dir "init.el")))
    (org-babel-tangle-file org-file) (load init-file)))

(use-package org-download
  :config
  (setq org-download-display-inline-images t
        org-download-image-dir (expand "_img" user-notes-dir))
  :gfhook
  ('dired-mode-hook 'org-download-enable))

;;; notes.el ends here
#+end_src

***** Org roam (deactivated)
#+begin_src elisp
(use-package bug-hunter
  :ensure (:host github :repo "Malabarba/elisp-bug-hunter"))

(use-package org-roam
  :disabled t
  :config
  (setq org-roam-db-gc-threshold most-positive-fixnum)
  (setq org-roam-directory (expand user-notes-dir))
  (setq org-id-extra-files (org-roam--list-files org-roam-directory))

  (setq org-roam-capture-templates
        '(("d" "default" plain "%?"
           :immediate-finish t
           :if-new (file+head "${slug}.org"
                              "#+TITLE: ${title}\n#+lastmod: Time-stamp: <>\n\n")
           :unnarrowed t)
          ("t" "temp" plain "%?"
           :if-new(file+head "%<%Y%m%d%H%M%S>-${slug}.org"
                             "#+TITLE: ${title}\n#+lastmod: Time-stamp: <>\n\n")
           :immediate-finish t
           :unnarrowed t)
          ("p" "private" plain "%?"
           :if-new (file+head "${slug}-private.org"
                              "#+TITLE: ${title}\n")
           :immediate-finish t
           :unnarrowed t)))

  (setq org-roam-node-display-template
        (concat "${title:*} " (propertize "${tags:10}" 'face 'org-tag)))

  (setq org-roam-completion-system 'vertico
        org-roam-completion-everywhere t
        org-roam-mode-sections
        '(#'org-roam-backlinks-section
          #'org-roam-reflinks-section
          #'org-roam-unlinked-references-section))

  (org-roam-db-autosync-mode))
#+end_src

***** Misc
******* Keymap mapper

I still have to figure out where I can use this
#+begin_src elisp :noweb-ref nil
(setq default-input-method "programmer-dvorak")
(event-apply-hyper-modifier (kbd "3"))[16777232]
(defconst my-dvp-to-qwerty:numfn
  '(
    (?& . ?1)
    (?\[ . ?2)
    (?{ . ?3)
    (?} . ?4)
    (?\( . ?5)
    (?= . ?6)
    (?* . ?7)
    (?\) . ?8)
    (?+ . ?9)
    (?\] . ?0)
    (?! . ?-)
    (?# . ?=)

    (?% . ?!)
    (?7 . ?@)
    (?5 . ?#)
    (?3 . ?$)
    (?1 . ?%)
    (?9 . ?^)
    (?0 . ?&)
    (?2 . ?*)
    (?4 . ?\()
    (?6 . ?\))
    (?8 . ?_)
    (?` . ?+)
    ))

(defconst my-dvp-to-qwerty:layout
  '(
    (?\; . ?q)(?, . ?w)(?. . ?e)(?p . ?r)(?y . ?t)(?f . ?y)(?g . ?u)(?c . ?i)(?r . ?o)(?l . ?p)(?/ . ?[)(?@ . ?])
    (?a . ?a)(?o . ?s)(?e . ?d)(?u . ?f)(?i . ?g)(?d . ?h)(?h . ?j)(?t . ?k)(?n . ?l)(?s . ?\;)(?- . ?')
    (?' . ?z)(?q . ?x)(?j . ?c)(?k . ?v)(?x . ?b)(?b . ?n)(?m . ?m)(?w . ?,)(?v . ?.)(?z . ?/)

    (?: . ?Q)(?< . ?W)(?> . ?E)(?P . ?R)(?Y . ?T)(?F . ?Y)(?G . ?U)(?C . ?I)(?R . ?O)(?L . ?P)(?? . ?{)(?^ . ?})
    (?A . ?A)(?O . ?S)(?E . ?D)(?U . ?F)(?I . ?G)(?D . ?H)(?H . ?J)(?T . ?K)(?N . ?L)(?S . ?\:)(?_ . ?\")
    (?\" . ?Z)(?Q . ?X)(?J . ?C)(?K . ?V)(?X . ?B)(?B . ?N)(?M . ?M)(?W . ?<)(?V . ?>)(?Z . ?\?)
    ))

(defun parse-qwerty-to-dvp:numf (string)
  "STRING will be parsed to dvorak's numfn equivalent."
  (apply #'concat
         (mapcar
          (lambda (arg)
            (setq arg (format "%c" (or (car (rassoc arg my-dvp-to-qwerty:numfn)) arg))))
          string)))

(defun parse-dvp-to-qwerty:numf (string)
  "STRING will be parsed to qwerty's numfn equivalent."
  (apply #'concat
         (mapcar
          (lambda (arg)
            (setq arg (format "%c" (or (cdr (assoc arg my-dvp-to-qwerty:numfn)) arg))))
          string)))

(parse-dvp-to-qwerty:numf "[") ; 2
(parse-dvp-to-qwerty:numf "7") ; @
(parse-qwerty-to-dvp:numf "4") ; }
(parse-qwerty-to-dvp:numf "$") ; 3

(let ((key (format "<F-%s>" (parse-qwerty-to-dvp:numf "1")))) ; <F-1>
  (global-set-key (kbd key) 'help-map))

(global-set-key (vector (list 'control "<kp-1>")) (lambda () (message "oi")))
#+end_src
***** Denote
#+begin_src elisp
(use-package denote
  :ensure t
  :init
  (require 'denote-org-extras)
  (denote-rename-buffer-mode t)
  :hook
  (find-file-hook . denote-link-buttonize-buffer)
  (dired-mode . denote-dired-mode)
  :custom-face
  (denote-faces-link ((t (:slant italic))))
  :custom
  (denote-known-keywords '("rust"
                           "emacs"
                           "CS"
                           "philosophy"
                           "politics"
                           "economics"))
  :config
  (defun my-denote-tmr ()
    (interactive)
    (tmr "10" "Practice writing in my journal"))
  (add-hook 'denote-journal-extras-hook 'my-denote-tmr)

  (csetq denote-directory user-notes-dir)
  (map ju-notes-map
       "n" #'denote-create-note
       "j" #'denote-journal-extras-new-or-existing-entry
       "d" #'denote-date
       "i" #'denote-link-or-create
       "l" #'denote-find-link
       "b" #'denote-find-backlink
       "D" #'denote-org-dblock-insert-links
       "r" #'denote-rename-file-using-front-matter
       "R" #'denote-rename-file
       "k" #'denote-keywords-add
       "K" #'denote-keywords-remove))
#+end_src

***** Calendar
#+begin_src elisp
;;; Calendar
(map calendar-mode-map
     "n" #'calendar-forward-week
     "d" #'calendar-backward-week
     ;; forward:  f & t (t dvorak vim-like eq. j in qwerty)
     "t" #'calendar-forward-day
     "T" #'calendar-forward-month
     "f" #'calendar-forward-day
     "F" #'calendar-forward-month
     ;; backwards: b & h (h dvorak vim-like eq. k)
     "h" #'calendar-backward-day
     "H" #'calendar-backward-month
     "b" #'calendar-backward-day
     "B" #'calendar-backward-month)
#+end_src

***** idk
#+begin_src elisp
;;; notes.el ---  desc  -*- lexical-binding: t; -*-
;;; Commentary:
;; https://www.reddit.com/r/emacs/comments/d7x7x8/finally_fixing_indentation_of_quoted_lists/
;; https://emacs.stackexchange.com/questions/10230/how-to-indent-keywords-aligned
;;; Code:
(require 'core-packages)
(require 'core-lib)
(require 'keymaps)

(use-package dogears
  :ensure t
  :init
  (dogears-mode 1))

;; Denote extensions
(use-package consult-notes
  :ensure t
  :after denote
  :commands (consult-notes
             consult-notes-search-in-all-notes)
  :init
  (csetq consult-notes-file-dir-sources (list `("All" 'a "~/notes")))
  (consult-notes-denote-mode)
  (map leader-map "C-n" #'consult-notes)
  (map ju-notes-map
       "f" #'consult-notes
       "s" #'consult-notes-search-in-all-notes))

(use-package org-sticky-header
  :ensure t
  :hook (org-mode . org-sticky-header-mode))

(use-package org-gtd
  :disabled t
  :ensure t
  :after org
  :init
  (setq ju-gtd-map (make-sparse-keymap))
  (map ju-notes-map
       "g" (cons "GTD" ju-gtd-map))

  (map ju-gtd-map
       "c" (cons "GTD: Capture" #'org-gtd-capture)
       "p" (cons "GTD: Process" #'org-gtd-process-inbox)
       "e" (cons "GTD: Engage" #'org-gtd-engage)
       "o" (cons "GTD: Organize" #'org-gtd-organize))

  (csetq org-gtd-update-ack "3.0.0"
         org-gtd-directory user-notes-dir))

;; Easy insertion of weblinks
(use-package org-web-tools)
(use-package ob-mermaid)

(use-package persistent-scratch
  :hook
  (after-init . persistent-scratch-setup-default)
  :init
  (persistent-scratch-autosave-mode)
  (csetq persistent-scratch-save-file (concat cache-dir "permanent-scratch.org")
         persistent-scratch-backup-directory (concat cache-dir "perm-scratch/"))
  :config
  (map ju-menu-map "x" #'scratch-buffer))

;; Modernise Org mode interface
(use-package olivetti
  :demand t)


(use-package org-bookmark-heading
  :ensure t)
#+end_src

#+RESULTS:

** VCS
:PROPERTIES:
:header-args: :noweb-ref git-cfg
:END:

#+BEGIN_SRC elisp :tangle layers/git.el :noweb-ref :noweb yes
;; -*- lexical-binding: t; -*-

<<git-cfg>>

(provide 'git)
;;; git.el ends here.
#+END_SRC

#+begin_src elisp
;; Ediff
(require 'ediff)
(csetq ediff-split-window-function #'split-window-vertically
       ediff-window-setup-function #'ediff-setup-windows-plain)

;; Org blocks indent to 0 instead of 2
(csetq org-edit-src-content-indentation 0)
(csetq pop-up-windows t
       use-file-dialog nil)

(use-package magit
  :defer 3
  :ensure t
  :config
  (ju-after-gui
    (core-handle-popup-same-window magit-status-mode)
    (core-handle-popup-same-window magit-log-mode)
    (core-handle-popup-same-window magit-cherry-mode)
    (core-handle-popup-same-window magit-log-select-mode)
    (core-handle-popup-other-window magit-revision-mode)
    (core-handle-popup-other-window-no-select magit-diff-mode))
  (map ju-git-map
       "g" #'magit
       "c" #'magit-clone))

(use-package pcre2el
  :ensure t)

(use-package magit-todos
  :ensure t
  :after magit
  :init (magit-todos-mode 1))

(use-package forge
  :ensure t
  :after magit)

(use-package git-commit
  :config
  ;; so `fill-paragraph' works correctly for bullet points
  (setq git-commit-major-mode 'org-mode)
  (general-add-hook 'git-commit-mode-hook
                    #'auto-fill-mode))
#+end_src

** Text Editing
:PROPERTIES:
:header-args: :noweb-ref text-editing-cfg
:END:

#+BEGIN_SRC elisp :tangle layers/text-editing.el :noweb-ref :noweb yes
;; -*- lexical-binding: t; -*-

<<text-editing-cfg>>

(provide 'text-editing)
;;; text-editing.el ends here.
#+END_SRC

#+begin_src elisp
  (require 'popup-handler)

  ;; Settings --------------------------------
  (setq default-input-method "korean-hangul")

  (setq mark-even-if-inactive t)
  (setq kill-whole-line t)

  ;; Dabrev
  (setq dabbrev-case-fold-search t)
  (setq dabbrev-abbrev-char-regexp "\\sw\\|\\s_"
        dabbrev-abbrev-skip-leading-regexp "\\$\\|\\*\\|/\\|=")

  (add-hook 'text-mode-hook 'visual-line-mode)
  (add-hook 'text-mode-hook 'toggle-word-wrap)

  ;; Save clipboard before changing it
  (setq save-interprogram-paste-before-kill t)

  (global-set-key (kbd "C-S-d") 'duplicate-line)
  ;; Key to kill-whole-line
  (global-set-key (kbd "C-S-k") 'kill-whole-line)
  (global-set-key (kbd "C-k") 'kill-visual-line-join)


  (global-set-key "\C-z" 'zap-up-to-char)
  (global-set-key "\C-a" 'back-to-indentation-or-beginning)

  ;; Use M-j to join lines. C-j splits them, so it's all good.
  (global-set-key (kbd "M-j") 'ju-join-line)

  ;; Easily comment and uncomment region
  (global-set-key (kbd "C-c ;") 'comment-region)

  ;;(define-key global-map (kbd "M-o") 'open-previous-line)
  ;;(define-key global-map (kbd "C-j") 'open-next-line)

  (define-key global-map (kbd "C-'") 'open-previous-line)
  (define-key global-map (kbd "M-'") 'use-register-dwim)

  ;; --------------------------------------
  ;;              Functions
  ;; --------------------------------------

  (defun join-line-below ()
    "Join line below instead of current, keeping cursor on place."
    (interactive)
    (save-excursion
      (forward-line)
      (join-line)))

  (defun kill-visual-line-join ()
    "When point is on eol, join line below, if is bol, kill line and join."
    (interactive)
    (cond
     ((bolp)
      (save-excursion
        (kill-visual-line)
        (delete-char)))
     ((eolp)
      (progn
        (join-line-below)
        (indent-according-to-mode)))
     (t (kill-visual-line))))

  (defun get-region-pos ()
    (cl-destructuring-bind (beg . end)
        (if (region-active-p)
            (cons (region-beginning)
                  (region-end))
          (cons (line-beginning-position)
                (line-end-position)))
      (cons beg end)))

  (defun my-kill-ring-save ()
    "An `kill-ring-save' wrapper.
  If no active region, yank from point to eol, instead of mark."
    (interactive)
    (if (equal mark-active nil)
        (kill-ring-save (point) (line-end-position))
      (kill-ring-save (point) (mark))))

  (global-set-key "\M-w" 'my-kill-ring-save)
  (global-set-key "\C-y" 'yank)

  (defvar newline-and-indent t
    "Modify the behavior of the open-*-line functions to cause them to autoindent.")
  ;;; behave like vi's O command
  (defun open-previous-line (&optional arg)
    "Open a new line before the current one.
    See also `newline-and-indent'."
    (interactive "p")
    (save-excursion
      (beginning-of-line)
      (open-line (cond (arg arg) (t 1)))
      (unless arg
        (when newline-and-indent
          (indent-according-to-mode))))

    (when (and (eolp)
               (bolp))
      (next-line)))

  (defun open-next-line (&optional arg)
    "Open a new line before the current one.
    See also `newline-and-indent'."
    (interactive "p")
    (save-excursion
      (next-line)
      (beginning-of-line)
      (open-line (cond (arg arg) (t 1)))
      (unless arg
        (indent-according-to-mode))))

  ;;;###autoload
  (defun duplicate-line (&optional arg)
    "Duplicate it. With prefix ARG, duplicate ARG lines following the current one."
    (interactive "p")
    (cl-destructuring-bind (beg . end) (if (region-active-p)
                                           (cons (region-beginning)
                                                 (region-end))
                                         (cons (line-beginning-position)
                                               (line-end-position)))
      (embark-insert arg)))

  (defun backward-kill-word-or-region (&optional arg)
    "Kill word backward if region is inactive; else kill region"
    (interactive "p")
    (if (region-active-p)
        (kill-region (region-beginning) (region-end))
      (backward-kill-word arg)))
  ;; --------------------------------------

  ;;;###autoload
  (defun store-register-dwim (arg register)
    "Store what I mean in a register.
  With an active region, store or append (with \\[universal-argument]) the
  contents, optionally deleting the region (with a negative
  argument). With a numeric prefix, store the number. With \\[universal-argument]
  store the frame configuration. Otherwise, store the point."
    (interactive
     (list current-prefix-arg
           (register-read-with-preview "Store in register: ")))
    (cond
     ((use-region-p)
      (let ((begin (region-beginning))
            (end (region-end))
            (delete-flag (or (equal arg '-)  (equal arg '(-4)))))
        (if (consp arg)
            (append-to-register register begin end delete-flag)
          (copy-to-register register begin end delete-flag t))))
     ((numberp arg) (number-to-register arg register))
     (t (point-to-register register arg))))

  ;;;###autoload
  (defun use-register-dwim (register &optional arg)
    "Do what I mean with a register.
  For a window configuration, restore it. For a number or text, insert it.
  For a location, jump to it."
    (interactive
     (list (register-read-with-preview "Use register: ")
           current-prefix-arg))
    (condition-case nil
        (jump-to-register register arg)
      (user-error (insert-register register arg))))

  ;;;###autoload
  (defun save-buffer-if-visiting-file (&optional args)
    "Save the current buffer only if it is visiting a file"
    (interactive)
    (if (buffer-file-name)
        (save-buffer args)))
  (add-hook 'auto-save-hook 'save-buffer-if-visiting-file)
  ;; ------------------------------------------

  (defun back-to-indentation-or-beginning () (interactive)
         (if (= (point) (progn (beginning-of-line-text) (point)))
             (beginning-of-line)))

  ;; Packages --------------------------------

  (use-package visual-fill-column
    :hook ((text-mode-hook . visual-fill-column-mode)
            (prog-mode-hook . visual-fill-column-mode))
    :init
    (setq-default visual-fill-column-width 150)
    (setq-default visual-fill-column-center-text t))

  (use-package selection-highlight-mode
    :ensure (:host github
                   :repo "balloneij/selection-highlight-mode")
    :config (selection-highlight-mode))

  (use-package indent-guide
    :config
    (add-hook 'prog-mode 'indent-guide-mode)
    (set-face-background 'indent-guide-face "unspecified"))

  (use-package whitespace
    :ensure nil
    :demand t
    :config
    (map ju-toggle-map "w" #'whitespace-mode)
    (csetq whitespace-style
           '(face tabs spaces trailing lines space-before-tab
                  newline indentation empty space-after-tab space-mark
                  tab-mark newline-mark missing-newline-at-eof)
           ;; use `fill-column' value
           whitespace-line-column 120
           whitespace-display-mappings
           '((tab-mark ?\t [?\xBB ?\t])
             (newline-mark ?\n [? ?\n])
             (trailing-mark ?\n [? ?\n])))

    (defun add-lines-tail ()
      "Add lines-tail to `whitespace-style' and refresh `whitespace-mode'."
      (setq-local whitespace-style (cons 'lines-tail whitespace-style))
      (whitespace-mode))

    (add-hook 'prog-mode-hook #'add-lines-tail))

  (setq prettify-symbols-unprettify-at-point 'right-edge)

  (defvar default-prettify-alist ())
  (setq default-prettify-alist
        '(("lambda" . "")))

  (defun default-prettify-mode()
    "Enable a prettify with custom symbols"
    (interactive)
    (setq prettify-symbols-alist default-prettify-alist)
    (prettify-symbols-mode -1)
    (prettify-symbols-mode +1)
    (setq prettify-symbols-unprettify-at-point 'right-edge))

  (add-hook! '(prog-mode-hook text-mode-hook) #'default-prettify-mode)

  (defvar org-prettify-alist
    '(("[#a]"  . ? )
      ("[#b]"  . ?)
      ("[#c]"  . ?)
      ("[#d]"  . ?)
      ("[#e]"  . ?)
      ("[ ]"   . ? )
      ("[X]"   . ? )
      ("[-]"   . "" )
      ("#+results:"   . ? )
      ("#+begin_src"  . ? )
      ("#+end_src"    . ? )
      (":end:"        . ?)))

  ;; Up-case all keys so "begin_src" and "BEGIN_SRC" has the same icon
  (setq org-prettify-alist
        (append (mapcan (lambda (x) (list x (cons (upcase (car x)) (cdr x))))
                        org-prettify-alist)
                org-prettify-alist))

  (setq org-prettify-alist
        (append default-prettify-alist org-prettify-alist))

  (defun org-prettify-mode()
    (interactive)
    (setq prettify-symbols-alist org-prettify-alist)
    (prettify-symbols-mode -1)
    (prettify-symbols-mode +1)
    (setq prettify-symbols-unprettify-at-point 'right-edge))

  (add-hook! 'org-mode-hook #'org-prettify-mode)

  (use-package dictionary
    :ensure t
    :bind (:map text-mode-map
                ("M-." . dictionary-lookup-definition))
    :init
    (add-to-list 'display-buffer-alist
                 '("^\\*dictionary\\*" display-buffer-in-direction
                   (side . right)
                   (window-width . 50)))
    :custom
    (dictionary-server "dict.org"))

  (use-package artbollocks-mode)

  (use-package jinx
    :disabled
    :init
    (noct-after-buffer (global-jinx-mode))
    :config
    (global-key "C-." #'jinx-correct))
#+end_src

#+RESULTS:

** OS
:PROPERTIES:
:header-args: :noweb-ref OS-cfg
:END:

#+BEGIN_SRC elisp :tangle layers/OS.el :noweb-ref :noweb yes
;; -*- lexical-binding: t; -*-

<<OS-cfg>>

(provide 'OS)
;;; os.el ends here.
#+END_SRC

#+begin_src elisp
;; Linux
(defun ju/system-sleep ()
  (interactive)
  (save-all-history)
  (call-process "systemctl" nil nil nil "suspend"))
(defalias 'ju/system-suspend 'ju/system-sleep)

(defun ju/keymap-dvorak ()
  (interactive)
  (call-process "setxkbmap" nil nil nil "-variant" "dvp"))

(defun ju/keymap-qwerty ()
  (interactive)
  (call-process "setxkbmap" nil nil nil "-variant" ","))

(defun ju/system-shutdown ()
  (interactive)
  (save-all-history)
  (call-process "systemctl" nil nil nil "poweroff"))

(defun ju/system-logout ()
  (interactive)
  (save-all-history)
  (call-process "pkill" nil nil nil
                "-KILL" "-u" (user-login-name)))

;; NixOS
(defun nixos-rebuild ()
  "Rebuild the nixos system."
  (interactive)
  (display-buffer
   (get-buffer-create "*nixos-rebuild*")
   '((display-buffer-below-selected display-buffer-at-bottom)
     (inhibit-same-window . t)))
  (start-process "nixos-rebuild" "*nixos-rebuild*" "sudo"
                 "nixos-rebuild" "switch"))
#+end_src

** Readers
:PROPERTIES:
:header-args: :noweb-ref readers-cfg
:END:

#+BEGIN_SRC elisp :tangle layers/readers.el :noweb-ref :noweb yes
;; -*- lexical-binding: t; -*-

<<readers-cfg>>

(provide 'readers)
;;; readers.el ends here.
#+END_SRC

#+begin_src elisp
(require 'core-packages)

(use-package pdf-tools
  :ensure t
  ;; I use nix bin instead of compiling
  :init
  (csetq-default doc-view-resolution nil)
  (pdf-loader-install t)
  :mode (("\\.[pP][dD][fF]\\'" . pdf-view-mode))
  :config
  (map pdf-view-mode-map
       "d" #'pdf-view-previous-page-command
       "h" (lambda () (interactive) (pdf-view-next-line-or-next-page 5))
       "t" (lambda () (interactive) (pdf-view-previous-line-or-previous-page 5))
       "n" #'pdf-view-next-page-command
       "C-#" #'pdf-view-enlarge
       "C-!" #'pdf-view-shrink
       ;; alternatively
       "g" #'image-bob
       "G" #'noct:pdf-view-goto-page
       "m" #'pdf-view-position-to-register
       "'" #'pdf-view-jump-to-register
       "/" #'pdf-occur
       "o" #'pdf-outline
       "f" #'pdf-links-action-perform
       "b" #'pdf-view-midnight-minor-mode
       "y" 'core:pdf-view-page-as-text
       "C-o" #'pdf-history-backward
       "C-i" #'pdf-history-forward)

  ;; Ediff
  (require 'ediff)
  (csetq ediff-split-window-function #'split-window-vertically
         ediff-window-setup-function #'ediff-setup-windows-plain)

  (add-hook 'pdf-tools-enabled-hook #'pdf-view-midnight-minor-mode)

  :preface
  (defun core:pdf-view-page-as-text ()
    "Inserts current pdf page into a buffer for keyboard selection."
    (interactive)
    (pdf-view-mark-whole-page)
    (pdf-view-kill-ring-save)
    (switch-to-buffer (make-temp-name "pdf-page"))
    (save-excursion
      (yank)))
  (defun noct:pdf-view-goto-page (count)
    "Goto page COUNT.
  If COUNT is not supplied, go to the last page."
    (interactive "P")
    (if count
        (pdf-view-goto-page count)
      (pdf-view-last-page))))

;; Biblio package for adding BibTeX records and download publications
(use-package biblio)
(use-package nov)

;; Configure Elfeed
(use-package elfeed
  :ensure t
  :init
  (map leader-map
       "re" #'elfeed)

  (csetq elfeed-db-directory (concat cache-dir "elfeed/")
         elfeed-show-entry-switch 'display-buffer)
  (add-hook 'elfeed-new-entry-hook #'elfeed-declickbait-entry)

  (defun elfeed-declickbait-entry (entry)
    (let ((title (elfeed-entry-title entry)))
      (setf (elfeed-meta entry :title)
            (elfeed-title-transform title))))

  (defun elfeed-title-transform (title)
    "Declickbait string TITLE."
    (let* ((trim "\\(?:\\(?:\\.\\.\\.\\|[!?]\\)+\\)")
           (arr (split-string title nil t trim))
           (s-table (copy-syntax-table)))
      (modify-syntax-entry ?\' "w" s-table)
      (with-syntax-table s-table
        (mapconcat (lambda (word)
                     (cond
                      ((member word '("AND" "OR" "IF" "ON" "IT" "TO"
                                      "A" "OF" "VS" "IN" "FOR" "WAS"
                                      "IS" "BE"))
                       (downcase word))
                      ((member word '("WE" "DAY" "HOW" "WHY" "NOW" "OLD"
                                      "NEW" "MY" "TOO" "GOT" "GET" "THE"
                                      "ONE" "DO" "YOU"))
                       (capitalize word))
                      ((> (length word) 3) (capitalize word))
                      (t word)))
                   arr " "))))
  )

(provide 'readers)
#+end_src
** Apps
*** Dir
:PROPERTIES:
:header-args: :noweb-ref dir-cfg
:END:

#+BEGIN_SRC elisp :tangle layers/dir.el :noweb-ref :noweb yes
;; -*- lexical-binding: t; -*-

<<dir-cfg>>

(provide 'dir)
;;; dir.el ends here.
#+END_SRC

#+begin_src elisp
(require 'core-packages)

(use-package dired
  :ensure nil
  :config
  (defun dired--recentf-fix (orig-fun &rest args)
    (let ((recentf-exclude '(".*")))
      (apply orig-fun args)))
  (advice-add 'dired-up-directory :around
              #'dired--recentf-fix))

(with-eval-after-load 'async
  (autoload 'dired-async-mode "dired-async.el" nil t)
  (dired-async-mode 1))

(use-package dired-rsync
  :if (executable-find "rsync")
  :defer t)

(use-package dirvish
  :bind (("C-x C-j" . dirvish))
  :init
  ;; (csetq dired-omit-files
  ;;        (concat dired-omit-files "\\|^\\..*$"))
  (pushnew! savehist-additional-variables 'dirvish--history)
  (dirvish-override-dired-mode)
  :config
  (dirvish-peek-mode 1) ; Preview files in minibuffer

  (csetq dired-dwim-target t
         dired-recursive-copies 'always
         dired-recursive-deletes 'top
         dirvish-preview-dispatchers '(image gif video audio epub pdf archive)
         delete-by-moving-to-trash t)

  (setq dired-mouse-drag-files t) ; added in Emacs 29
  (setq mouse-drag-and-drop-region-cross-program t)

  (csetq dired-listing-switches
         ;; -v - natural sort numbers
         ;; --almost-all - all except . and ..
         (concat "-l -v --almost-all --group-directories-first "
                 "--time-style=long-iso"))

  (csetq dirvish-quick-access-entries
         '(
           ("r" "/"            "Root")
           ("h" "~/"           "Home")
           ("m" "/mnt/"        "Mount")
           ("d" "~/dev/"       "Dev")
           ("s" "~/sync/"      "Sync")
           ("c" "~/.config/"   "Config")
           ("D" "~/Downloads/" "Downloads")
           ("t" "~/.local/share/Trash/files/" "TrashCan")
           ))

  ;; (csetq dired-listing-switches (string-join '("--all"
  ;;                                              "--human-readable"
  ;;                                              "--time-style=long-iso"
  ;;                                              "--group-directories-first"
  ;;                                              "-lv1")
  ;;                                            " "))
  (setq mouse-1-click-follows-link nil)
  (define-key dirvish-mode-map (kbd "<mouse-1>") 'dirvish-subtree-toggle-or-open)
  (define-key dirvish-mode-map (kbd "<mouse-2>") 'dired-mouse-find-file-other-window)
  (define-key dirvish-mode-map (kbd "<mouse-3>") 'dired-mouse-find-file)

  ;; Verbose settings
  (let ((my/file (lambda (path &optional dir)
                   (expand-file-name path (or dir user-emacs-directory))))
        (my/dir (lambda (path &optional dir)
                  (expand-file-name (file-name-as-directory path)
                                    (or dir user-emacs-directory)))))
    (csetq image-dired-thumb-size             150
           image-dired-dir                    (funcall my/dir "dired-img")
           image-dired-db-file                (funcall my/file "dired-db.el")
           image-dired-gallery-dir            (funcall my/dir "gallery")
           image-dired-temp-image-file        (funcall my/file "temp-image" image-dired-dir)
           image-dired-temp-rotate-image-file (funcall my/file "temp-rotate-image" image-dired-dir)))

  (dirvish-define-attribute symlink-arrow
    "Show -> on symlinks but not full target."
    :when (and dired-hide-details-mode
               (default-value 'dired-hide-details-hide-symlink-targets))
    (when (< (+ f-end 4) l-end)
      (let ((ov (make-overlay (+ f-end 4) l-end)))
        (overlay-put ov 'invisible t) ov)))

  (general-pushnew (cons (list "png" "jpg" "jpeg" "webp") (list "mvi" "%f"))
                   dirvish-open-with-programs)

  (csetq dirvish-yank-overwrite-existing-files 'never
         dirvish-attributes '(all-the-icons file-size file-time collapse subtree-state vc-state)
         dirvish-yank-new-name-style 'append-to-filename
         dirvish-yank-new-name-style 'append-to-ext)

  (csetq dirvish-mode-line-position 'global
         dirvish-mode-line-format '(" " file-modes " " file-link-number " " file-user ":" file-group " "
                                    symlink omit vc-info
                                    :right
                                    (sort yank index)))

  (map dirvish-mode-map
       ;; https://github.com/alexluigit/dirvish/issues/186
       "<tab>" #'dirvish-subtree-toggle
       "RET" #'dired-find-file

       "A" #'gnus-dired-attach
       "a" #'dirvish-quick-access
       "b" #'dired-up-directory
       "D" #'dired-do-delete
       "d" #'dirvish-dispatch
       "e" #'dirvish-emerge-menu
       "F" #'dirvish-file-info-menu
       "f" #'dirvish-fd-jump

       ;; "l" #'diredp-find-file-reuse-dir-buffer
       "m" #'dired-mark
       "M" #'dirvish-layout-switch
       "i" #'dired-find-file
       "p" #'dired-previous-line
       "n" #'dired-next-line

       "h" nil
       "hp" #'dirvish-history-go-backward
       "hn" #'dirvish-history-go-forward
       "hj" #'dirvish-history-jump
       "hl" #'dirvish-history-last

       "o" #'dirvish-quicksort
       "O" #'dirvish-chxxx-menu
       "q" #'dirvish-quit
       "s" #'dirvish-quicksort
       "S" #'dirvish-setup-menu
       "t" #'dired-find-file
       "u" #'dired-unmark
       "U" #'dired-unmark-all-marks
       "y" #'dirvish-yank-menu
       "z" #'dirvish-setup-menu

       " " #'dired-next-line

       "C-y" nil
       "C-y p" #'dirvish-yank
       "C-y m" #'dirvish-move
       "C-y l" #'dirvish-symlink
       "C-y L" #'dirvish-relative-symlink
       "C-y h" #'dirvish-hardlink

       "%" nil
       "%u" 'dired-upcase
       "%l" 'dired-downcase
       "%d" 'dired-flag-files-regexp
       "%g" 'dired-mark-files-containing-regexp
       "%m" 'dired-mark-files-regexp
       "%r" 'dired-do-rename-regexp
       "%C" 'dired-do-copy-regexp
       "%H" 'dired-do-hardlink-regexp
       "%R" 'dired-do-rename-regexp
       "%S" 'dired-do-symlink-regexp
       "%&" 'dired-flag-garbage-files

       "*" nil
       "**" 'dired-mark-executables
       "*/" 'dired-mark-directories
       "*@" 'dired-mark-symlinks
       "*%" 'dired-mark-files-regexp
       "*c" 'dired-change-marks
       "*s" 'dired-mark-subdir-files
       "*m" 'dired-mark
       "*u" 'dired-unmark
       "*?" 'dired-unmark-all-files
       "*!" 'dired-unmark-all-marks
       "U" 'dired-unmark-all-marks
       "* <delete>" 'dired-unmark-backward
       "* C-n" 'dired-next-marked-file
       "* C-p" 'dired-prev-marked-file
       )

  ;; truncate long file names instead of wrapping
  (add-hook 'dirvish-find-entry-hook (lambda (&rest _)
                                       (setq-local truncate-lines t)))
  (add-hook 'dirvish-preview-setup-hook (defun dirvish--preview-setup ()
                                          (display-line-numbers-mode -1)
                                          (setq-local mode-line-format nil
                                                      truncate-lines t))))
#+end_src

* Lisp
** +mode-line
:PROPERTIES:
:header-args: :noweb-ref plus-mode-line-cfg
:END:

#+BEGIN_SRC elisp :tangle lisp/+mode-line.el :noweb-ref :noweb yes
;; -*- lexical-binding: t; -*-

<<plus-mode-line-cfg>>

(provide '+mode-line)
;;; +mode-line.el ends here.
#+END_SRC

#+begin_src elisp
(defun ju-major-mode-indicator ()
  "Return appropriate propertized mode line indicator for the major mode."
  (let ((indicator (cond
                    ((derived-mode-p 'text-mode) "")
                    ((derived-mode-p 'prog-mode) "")
                    ((derived-mode-p 'comint-mode) ">_")
                    (t ""))))
    (propertize indicator 'face 'shadow)))
#+end_src

** +ibuffer
:PROPERTIES:
:header-args: :noweb-ref plus-ibuffer-cfg
:END:

#+BEGIN_SRC elisp :tangle lisp/+ibuffer.el :noweb-ref :noweb yes
;; -*- lexical-binding: t; -*-

<<plus-ibuffer-cfg>>

(provide '+ibuffer)
;;; +ibuffer.el ends here.
#+END_SRC

#+begin_src elisp
(require 'ibuffer)

(csetq ibuffer-saved-filter-groups
       '(("default"
          ;; ("Modified" (predicate buffer-modified-p (current-buffer)))
          ("Dired" (mode . dired-mode))
          ("Notes" (or (filename . "^~/sync/")
                       (filename . "^~/docs/")))
          ("Config" (or (filename . "^.+/\\.config/emacs/.+$")
                        (filename . "^.+/\\~/sync/config/.+$")))
          ("Magit" (name . "magit\\*"))
          ("Rust" (predicate . (and (eq major-mode 'rust-mode)
                                    (not (string-match-p "spec\\.rs\\'"
                                                         buffer-file-name)))))
          ("Tests" (name . "spec\\.rs\\'"))

          ("EXWM" (mode . exwm-mode))

          ("Help" (or (mode . helpful-mode)
                      (mode . help-mode)))

          ("Gnus" (or
                   (mode . message-mode)
                   (mode . bbdb-mode)
                   (mode . mail-mode)
                   (mode . gnus-group-mode)
                   (mode . gnus-summary-mode)
                   (mode . gnus-article-mode)
                   (name . "^\\.bbdb$")
                   (name . "^\\.newsrc-dribble")))
          ("*internal*" (name . "\\*"))))
       ;; Modify the default ibuffer-formats
       ibuffer-formats
       '((mark modified read-only locked " "
               (name 20 20 :left :elide)
               " "
               (filename-and-process 40 -1)
               " "
               (+jun/size-h 12 -1 :right :elide)
               "| "
               (mode 20 -1))
         (mark " "
               (name 20 6)
               " " filename)))

(setq mp/ibuffer-collapsed-groups (list "Emacs" "*Internal*"))

(defadvice ibuffer (after collapse-helm)
  (dolist (group mp/ibuffer-collapsed-groups)
    (progn
      (goto-char 1)
      (when (search-forward (concat "[ " group " ]") (point-max) t)
        (progn
          (move-beginning-of-line nil)
          (ibuffer-toggle-filter-group)))))
  (goto-char 1)
  (search-forward "[ " (point-max) t))

(ad-activate 'ibuffer)

;; Use human readable Size column instead of original one
(defun --human-readable-file-sizes-to-bytes (string)
  "Convert a human-readable file size into bytes."
  (interactive)
  (cond
   ((string-suffix-p "G" string t)
    (* 1000000000 (string-to-number (substring string 0 (- (length string) 1)))))
   ((string-suffix-p "M" string t)
    (* 1000000 (string-to-number (substring string 0 (- (length string) 1)))))
   ((string-suffix-p "K" string t)
    (* 1000 (string-to-number (substring string 0 (- (length string) 1)))))
   (t
    (string-to-number (substring string 0 (- (length string) 1))))));;

(defun --bytes-to-human-readable-file-sizes (bytes)
  "Convert number of bytes to human-readable file size."
  (interactive)
  (cond
   ((> bytes 1000000000) (format "%10.1fG" (/ bytes 1000000000.0)))
   ((> bytes 100000000) (format "%10.0fM" (/ bytes 1000000.0)))
   ((> bytes 1000000) (format "%10.1fM" (/ bytes 1000000.0)))
   ((> bytes 100000) (format "%10.0fk" (/ bytes 1000.0)))
   ((> bytes 1000) (format "%10.1fk" (/ bytes 1000.0)))
   (t (format "%10d" bytes))));;

(define-ibuffer-column +jun/size-h
  (:name "Size"
         :inline t
         :summarizer
         (lambda (column-strings)
           (let ((total 0))
             (dolist (string column-strings)
               (setq total
                     ;; like, ewww ...
                     (+ (float (--human-readable-file-sizes-to-bytes string))
                        total)))
             (--bytes-to-human-readable-file-sizes total))))
  (--bytes-to-human-readable-file-sizes (buffer-size)))
#+end_src

** tangle
:PROPERTIES:
:header-args: :noweb-ref plus-tangle-cfg
:END:

#+BEGIN_SRC elisp :tangle lisp/juni-tangle.el :noweb-ref :noweb yes
;; -*- lexical-binding: t; -*-

<<plus-tangle-cfg>>

(provide 'juni-tangle)
;;; juni-tangle.el ends here.
#+END_SRC

#+begin_src elisp
(eval-when-compile
  (defconst juni-init-file (concat emacs-dir "juni-config.org")
    "Main init file."))

(defconst juni-unclean-init-file
  (concat emacs-dir "juni-unclean.org")
  "Not yet tracked init file.")

;; http://www.holgerschurig.de/en/emacs-efficiently-untangling-elisp/
(defun tangle-section-canceled ()
  "Return t if the current section header was CANCELED, else nil."
  (save-excursion
    (if (re-search-backward "^\\*+\\s-+\\(.*?\\)?\\s-*$" nil t)
        (string-prefix-p "CANCELED" (match-string 1))
      nil)))

(defun tangle-config-org (orgfile elfile &optional demote-errors)
  "Write all source blocks from ORGFILE into ELFILE.

If DEMOTE-ERRORS is non-nil, wrap each source block with `with-demoted-errors'.

Only source blocks that meet these requirements will be tangled:
- not marked as :tangle no
- have a source-code of =emacs-lisp= or =elisp=
- doesn't have the todo-marker CANCELED"
  (let* (body-list
         (gc-cons-threshold most-positive-fixnum)
         (org-babel-src-block-regexp
          (concat
           ;; (1) indentation                 (2) lang
           "^\\([ \t]*\\)#\\+begin_src[ \t]+\\([^ \f\t\n\r\v]+\\)[ \t]*"
           ;; (3) switches
           "\\([^\":\n]*\"[^\"\n*]*\"[^\":\n]*\\|[^\":\n]*\\)"
           ;; (4) header arguments
           "\\([^\n]*\\)\n"
           ;; (5) body
           "\\([^\000]*?\n\\)??[ \t]*#\\+end_src")))
    (with-temp-buffer
      (insert-file-contents orgfile)
      (goto-char (point-min))
      (while (re-search-forward org-babel-src-block-regexp nil t)
        (let ((lang (match-string 2))
              (args (match-string 4))
              (body (match-string 5))
              (canc (tangle-section-canceled)))
          (when (and (or (string= lang "emacs-lisp")
                         (string= lang "elisp"))
                     (not (string-match-p ":tangle\\s-+no" args))
                     (not canc))
            (if demote-errors
                (push (concat "(let (debug-on-error)\n"
                              "(with-demoted-errors \"Init error: %S\"\n"
                              body
                              "))\n\n")
                      body-list)
              (push (concat body "\n")
                    body-list))))))
    (with-temp-file elfile
      ;; NOTE this could potentially cause problems
      (insert (format ";; Don't edit this file, edit %s instead ... -*- lexical-binding: t -*-\n\n"
                      orgfile))
      (apply #'insert (reverse body-list)))
    (message "Wrote %s ..." elfile)))

(defun juni-tangle-org-init (file &optional load compile retangle demote-errors)
  "Tangle org init FILE if it has not already been tangled.
If LOAD is non-nil, load it as well.  If RETANGLE is non-nil,
tangle FILE even if it is not newer than the current tangled
file.  If COMPILE is non-nil, and the uncompiled file is newer,
compile it.  If DEMOTE-ERRORS is non-nil, wrap each source block
with `with-demoted-errors'.

If both LOAD and COMPILE are specified, load the compiled version
of FILE if it is newer than the tangled version.  Otherwise load
the tangled version (since this is much faster than compiling and
then loading).

Only compile if COMPILE is non-nil and LOAD is nil.  In this case,
load the tangled init FILE first.  Compiling after loading ensures
that all required functionality is available (have to add
everything under ~/.emacs.d/straight/build to `load-path' in an
`eval-when-compile', run `straight-use-package-mode' so :straight
is recognized, etc., etc.; it's easier to just compile afterwards).

When there are no errors loading the tangled file, save it with a
\"-stable.el\" or \"-stable.elc\" suffix (depending on which was
loaded)."
  (let* ((base-file (file-name-sans-extension file))
         (org-init file)
         (init-tangled (if demote-errors
                           (format "%s-demoted-errors.el" base-file)
                         (concat base-file ".el")))
         (init-compiled (concat init-tangled "c"))
         (init-tangled-stable (concat base-file "-stable.el"))
         (init-compiled-stable (concat init-tangled-stable "c")))
    (when (or retangle
              (not (file-exists-p init-tangled))
              (file-newer-than-file-p org-init init-tangled))
      (tangle-config-org org-init init-tangled demote-errors))

    (cond ((and load compile (file-newer-than-file-p init-compiled init-tangled))
           (load-file init-compiled)
           ;; successfully loaded without errors; save stable configuration
           (copy-file init-compiled init-compiled-stable t))
          (load
           (load-file init-tangled)
           (unless demote-errors
             ;; successfully loaded without errors; save stable configuration
             (copy-file init-tangled init-tangled-stable t)))
          ((and compile
                ;; using `not' and this order because of the behavior of
                ;; `file-newer-than-file-p' when a file does not exist
                (not (file-newer-than-file-p init-compiled init-tangled)))
           (load-file init-tangled)
           (byte-compile-file init-tangled)))))

(defun tangle-config (&optional load compile retangle demote-errors)
  "Tangle awaken.org.
LOAD, COMPILE, RETANGLE, and DEMOTE-ERRORS are passed to `juni-tangle-org-init'."
  (interactive)
  (juni-tangle-org-init juni-init-file load compile retangle demote-errors)
  ;; TODO clean and move everything to awaken.org
  (when (file-exists-p juni-unclean-init-file)
    (juni-tangle-org-init juni-unclean-init-file load compile retangle demote-errors)))
#+end_src

** +org
:PROPERTIES:
:header-args: :noweb-ref plus-org-cfg
:END:

#+BEGIN_SRC elisp :tangle lisp/+org.el :noweb-ref :noweb yes
;; -*- lexical-binding: t; -*-

<<plus-org-cfg>>

(provide '+org)
;;; +org.el ends here.
#+END_SRC

#+begin_src elisp
(require 'org)

(defun +org-toggle-todo-and-fold ()
  (interactive)
  (save-excursion
    (org-back-to-heading t) ;; Make sure command works even if point is
    ;; below target heading
    (cond ((looking-at "\*+ TODO")
           (org-todo "DONE")
           (hide-subtree))
          ((looking-at "\*+ DONE")
           (org-todo "TODO")
           (hide-subtree))
          (t (message "Can only toggle between TODO and DONE.")))))

(defun +org-cycle-only-current-subtree-h (&optional arg)
  "Toggle the local fold at the point, and no deeper.
                  `org-cycle's standard behavior is to cycle between three levels: collapsed,
                  subtree and whole document. This is slow, especially in larger org buffer. Most
                  of the time I just want to peek into the current subtree -- at most, expand
                  ,*only* the current subtree.

                  All my (performant) foldings needs are met between this and `org-show-subtree'
                  (on zO for evil users), and `org-cycle' on shift-TAB if I need it."
  (interactive "P")
  (unless (or (eq this-command 'org-shifttab)
              (and (bound-and-true-p org-cdlatex-mode)
                   (or (org-inside-LaTeX-fragment-p)
                       (org-inside-latex-macro-p))))
    (save-excursion
      (org-beginning-of-line)
      (let (invisible-p)
        (when (and (org-at-heading-p)
                   (or org-cycle-open-archived-trees
                       (not (member org-archive-tag (org-get-tags))))
                   (or (not arg)
                       (setq invisible-p (outline-invisible-p (line-end-position)))))
          (unless invisible-p
            (setq org-cycle-subtree-status 'subtree))
          (org-cycle-internal-local)
          t)))))
#+end_src
